<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux(22) - 进程池</title>
    <url>/2020/02/06/Linux%20%5B23%5D%20-%20%E8%BF%9B%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="进程池工作流程"><a href="#进程池工作流程" class="headerlink" title="进程池工作流程"></a>进程池工作流程</h1><p>首先我们通过父进程创建了很多个子进程，每个子进程与父进程直接都有一条全双工的管道，<a id="more"></a>父进程是我们的代理，当1号客户端请求连接下载文件时，父进程接收到请求，产生 new_fd ，并把 new_fd 发送给非忙碌的子进程 a ，由子进程 a 将文件传输给 1号客户端。这时2号客户端请求下载文件，父进程接收请求得到new_fd, 由于这时子进程 a忙碌，所以将new_fd 发送给子进程 b ，由 子进程 b 负责给 2 号客户端下载文件。</p>
<h1 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h1><p>父进程管理子进程所使用的数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;   <span class="comment">//子进程的 pid</span></span><br><span class="line"><span class="keyword">int</span> fd;      <span class="comment">// 管道的一端</span></span><br><span class="line">short busy;  <span class="comment">// 代表子进程是否忙碌， 0 代表非忙碌， 1 代表忙碌</span></span><br><span class="line">&#125;process_data;</span><br></pre></td></tr></table></figure>
<p>创建多少个子进程，我们就用多少个对应的结构体管理子进程。</p>
<h1 id="进程间传递文件描述符"><a href="#进程间传递文件描述符" class="headerlink" title="进程间传递文件描述符"></a>进程间传递文件描述符</h1><h2 id="1-初始化socketpair-类型描述符"><a href="#1-初始化socketpair-类型描述符" class="headerlink" title="1.初始化socketpair 类型描述符"></a>1.初始化socketpair 类型描述符</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">socketpair(AF_LOCAL,SOCK_STREAM,<span class="number">0</span>,fds);</span><br></pre></td></tr></table></figure>

<h2 id="2-sendmsg发送描述符"><a href="#2-sendmsg发送描述符" class="headerlink" title="2.sendmsg发送描述符"></a>2.sendmsg发送描述符</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先定义一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgsdr</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Sendmsg关键是初始化 msghdr 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *msg_name; <span class="comment">/* optional address */</span>                 <span class="comment">//没用</span></span><br><span class="line">    <span class="keyword">socklen_t</span> msg_namelen; <span class="comment">/* size of address */</span>           <span class="comment">//没用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span> <span class="comment">/* scatter/gather array */</span>      <span class="comment">//没用</span></span><br><span class="line">    <span class="keyword">size_t</span> msg_iovlen; <span class="comment">/* # elements in msg_iov */</span>         <span class="comment">//没用</span></span><br><span class="line">    <span class="keyword">void</span> *msg_control; <span class="comment">/* ancillary data, see below */</span>     <span class="comment">//关键，即下面的cmsghdr 结构体地址</span></span><br><span class="line">    <span class="keyword">size_t</span> msg_controllen; <span class="comment">/* ancillary data buffer len */</span> <span class="comment">//cmsghdr 结构体的长度</span></span><br><span class="line">    <span class="keyword">int</span> msg_flags; <span class="comment">/* flags (unused) */</span>                    <span class="comment">//没用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Cmsg构造结构体 cmsghdr</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line"><span class="keyword">socklen_t</span> cmsg_len;  <span class="comment">/* data byte count, including header */</span></span><br><span class="line"><span class="keyword">int</span> cmsg_level;      <span class="comment">/* originating protocol */</span></span><br><span class="line"><span class="keyword">int</span> cmsg_type;       <span class="comment">/* protocol specific type */</span></span><br><span class="line"><span class="comment">/* followed by unsigned char cmsg_data[];</span></span><br></pre></td></tr></table></figure>

<p>用法：</p>
<p>首先定义变长结构体指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span>;</span></span><br></pre></td></tr></table></figure>

<p>cmsg_len中存取 cmsghdr 结构体的长度，通过 CMSG_LEN 进行计算，我们传递的 fd 的大小为整型四个字节，所以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Int len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<p>然后为结构体申请空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cmsg = (struct cmsghdr *)<span class="built_in">calloc</span>(<span class="number">1</span>,len);</span><br><span class="line">Cmsg--&gt;cmsg_len = len；</span><br><span class="line">cmsg--&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">Cmsg--&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line"><span class="keyword">int</span> *fdptr;</span><br><span class="line">fdptr= (<span class="keyword">int</span> *) CMSG_DATA(cmsg);</span><br><span class="line">*fdptr = fd;</span><br></pre></td></tr></table></figure>

<p>最后就可以通过<code>sendmsg</code>来发送文件描述符。</p>
<h2 id="3-Recvmsg接收文件描述符"><a href="#3-Recvmsg接收文件描述符" class="headerlink" title="3.Recvmsg接收文件描述符"></a>3.Recvmsg接收文件描述符</h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 - malloc和calloc</title>
    <url>/2020/02/06/C%E8%AF%AD%E8%A8%80%20-%20malloc%E5%92%8Ccalloc/</url>
    <content><![CDATA[<p>#malloc和calloc </p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">( <span class="keyword">size_t</span> <span class="built_in">size</span> )</span></span>; <span class="comment">//分配的大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">( <span class="keyword">size_t</span> numElements, <span class="keyword">size_t</span> sizeOfElement )</span></span>; <span class="comment">// 分配元素的个数和每个元素的大小</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>共同点：它们返回的都是 void * 类型，也就是说如果我们要为int或者其他类型的数据分配空间必须显式强制转换；</p>
</li>
<li><p>不同点：<br>用malloc分配存储空间时，必须由我们计算需要的字节数。如果想要分配5个int型的空间，那就是说需要5*sizeof(int)的内存空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * ip_a;</span><br><span class="line">ip_a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span> (<span class="keyword">int</span>) * <span class="number">5</span> );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>而用calloc就不需要这么计算了，直接：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ip_a = ( <span class="keyword">int</span>* )<span class="built_in">calloc</span>( <span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br></pre></td></tr></table></figure>

<h1 id="用malloc实现变长结构体"><a href="#用malloc实现变长结构体" class="headerlink" title="用malloc实现变长结构体"></a>用malloc实现变长结构体</h1><p>maloc申请内存空间，通过指针来实现变长结构体的赋值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">strnum</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">float</span> num2;</span><br><span class="line">&#125;strnum;</span><br><span class="line"><span class="keyword">char</span> * p = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">*(<span class="keyword">int</span> *)p = <span class="number">10</span>; </span><br><span class="line">*(<span class="keyword">float</span>)(p + <span class="number">4</span>) = <span class="number">5.5</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS(rpm管理)和ubuntu(dpkg管理) 基本操作</title>
    <url>/2020/02/05/Linux%20-%20CentOS(rpm%E7%AE%A1%E7%90%86)%E5%92%8Cubuntu(dpkg%E7%AE%A1%E7%90%86)/</url>
    <content><![CDATA[<h1 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h1><h2 id="rpm-文件管理"><a href="#rpm-文件管理" class="headerlink" title="rpm 文件管理"></a>rpm 文件管理</h2><p>rpm -i <rpm file name>     安装指定的 rpm 文件<br>rpm -e <package-name>      删除指定的软件包<a id="more"></a><br>rpm -U <rpm file name>     用指定的 rpm 文件升级同名包<br>rpm -q <package-name>     查询指定的软件包在系统中是否安装</p>
<p>其中查询还有详细的命令，如下:<br>rpm -qf &lt;/path/to/file&gt;     查询系统中指定文件所属的软件包<br>例如: rpm -qf /bin/ls<br>rpm -qa     查询系统中安装的所有RPM软件包<br>rpm -ql <package-name>     查询一个已安装软件包里所包含的文件<br>rpm -qc <package-name>     查看一个已安装软件包的配置文件位置<br>rpm -qi <package-name>     查询一个已安装软件包的描述信息<br>rpm -qd <package-name>     查看一个已安装软件包的文档安装位置<br>rpm -qR <package-name>     查询一个已安装软件包的最低依赖要求<br>rpm -V <package-name>     校验指定的软件包</p>
<p>rpm -qpl <package-name>     查询一个未安装软件包里所包含的文件<br>rpm -qpc <package-name>     查看一个未安装软件包的配置文件位置<br>rpm -qpi <package-name>     查询一个未安装软件包的描述信息<br>rpm -qpd <package-name>     查看一个未安装软件包的文档安装位置<br>rpm -qpR <package-name>     查询一个未安装软件包的最低依赖要求</p>
<h2 id="yum针对软件包操作常用命令"><a href="#yum针对软件包操作常用命令" class="headerlink" title="yum针对软件包操作常用命令"></a>yum针对软件包操作常用命令</h2><ol>
<li><p>使用YUM查找软件包<br>命令：yum search </p>
</li>
<li><p>列出所有可安装的软件包<br>命令：yum list </p>
</li>
<li><p>列出所有可更新的软件包<br>命令：yum list updates </p>
</li>
<li><p>列出所有已安装的软件包<br>命令：yum list installed </p>
</li>
<li><p>列出所有已安装但不在 Yum Repository 内的软件包<br>命令：yum list extras </p>
</li>
<li><p>使用YUM获取软件包信息<br>命令：yum info </p>
</li>
<li><p>列出所有可更新的软件包信息<br>命令：yum info updates </p>
</li>
<li><p>列出所有已安装的软件包信息<br>命令：yum info installed </p>
</li>
<li><p>列出所有已安装但不在 Yum Repository 内的软件包信息<br>命令：yum info extras </p>
</li>
<li><p>列出软件包提供哪些文件<br>命令：yum provides</p>
</li>
</ol>
<p>此部分原文链接：<a href="https://blog.csdn.net/don_chiang709/article/details/91571424" target="_blank" rel="noopener">https://blog.csdn.net/don_chiang709/article/details/91571424</a></p>
<hr>
<h1 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h1><h2 id="dpkg-文件管理"><a href="#dpkg-文件管理" class="headerlink" title="dpkg 文件管理"></a>dpkg 文件管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -l  [表达式] </span><br><span class="line">l &#x3D; list: 列出当前系统中所有的包.. (类似于rpm -qa)</span><br><span class="line"></span><br><span class="line">dpkg -S &lt;表达式&gt;  </span><br><span class="line">S &#x3D; Search: 查询系统中某个文件属于哪个软件包. (类似于rpm -qf)</span><br><span class="line"></span><br><span class="line">dpkg -s &lt;软件包名&gt; </span><br><span class="line">s &#x3D; status: 查询已安装的包的详细状态信息.</span><br><span class="line"></span><br><span class="line">dpkg -L &lt;软件包名&gt;  </span><br><span class="line">L &#x3D;  Listfiles: 查询系统中已安装的软件包所安装的位置. (类似于rpm -ql)</span><br><span class="line"></span><br><span class="line">dpkg-deb --info &lt;软件包名&gt; </span><br><span class="line">--列出一个deb软件包信息. (类似于 rpm -qpi)，可以检查deb包依赖关系Depends</span><br><span class="line">（实际上执行的是dpkg-deb 程序）</span><br><span class="line"></span><br><span class="line">dpkg-deb --contents &lt;软件包名&gt; </span><br><span class="line">--列出deb软件包所包含的内容. (类似于 rpm -qpd). 与dpkg -L 不同.</span><br><span class="line"></span><br><span class="line">该命令查询的是deb包内容, dpkg -L 查询是已经安装的包信息.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dpkg -i &lt;.deb 文件名&gt; </span><br><span class="line">i &#x3D; install:手动安装软件包(这个命令并不能解决软件包之前的依赖性问题)</span><br><span class="line"></span><br><span class="line">如果在安装某一个软件包的时候遇到了软件依赖的问题,可以用apt-get -f install在解决信赖性这个问题.</span><br><span class="line"></span><br><span class="line">dpkg -r  &lt;软件包名&gt;</span><br><span class="line">r &#x3D; remove: 卸载软件包.不是完全的卸载,它的配置文件还存在.</span><br><span class="line"></span><br><span class="line">dpkg -P &lt;软件包名&gt; </span><br><span class="line">P &#x3D; Purge: 强制卸载(但是还是不能解决软件包的依赖性的问题)</span><br></pre></td></tr></table></figure>


<p>原文链接：<a href="https://blog.csdn.net/hejinjing_tom_com/article/details/16981763/" target="_blank" rel="noopener">https://blog.csdn.net/hejinjing_tom_com/article/details/16981763/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS用gcc编译时提示缺少&lt;linux\unix.c&gt;头文件</title>
    <url>/2020/02/05/Linux%20-%20CentOS%E4%B8%8B%E7%BC%BA%E5%B0%91Linux_limits/</url>
    <content><![CDATA[<p>今天在阿里云(CentOS 7.3)上通过gcc命令，编译文件时突然出现如下错误：<a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@cj508 &#x2F;home&#x2F;wk $ gcc main.c</span><br><span class="line">In file included from &#x2F;usr&#x2F;include&#x2F;bits&#x2F;posix1_lim.h:160:0,</span><br><span class="line">                 from &#x2F;usr&#x2F;include&#x2F;dirent.h:233,</span><br><span class="line">                 from &#x2F;usr&#x2F;include&#x2F;func.h:7,</span><br><span class="line">                 from main.c:1:</span><br><span class="line">&#x2F;usr&#x2F;include&#x2F;bits&#x2F;local_lim.h:38:10: fatal error: linux&#x2F;limits.h: No such file or directory</span><br><span class="line"> #include &lt;linux&#x2F;limits.h&gt;</span><br><span class="line">          ^~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>

<p>意思就是致命错误：缺少linux/limits.h头文件</p>
<p>由于阿里云是几个人合用的，都是萌新，而且都拥有root的密码，所以只要一个人瞎搞，就很容搞出问题。</p>
<p>没办法，只能自己解决。</p>
<p>google一下，说是缺少一个包含此头文件的包。</p>
<p>那怎样知道是缺少哪个包呢？</p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum provides *&#x2F;linux&#x2F;limits.h</span><br></pre></td></tr></table></figure>

<p>就得到了很多包含此头文件的包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * centos-sclo-rh: mirrors.sonic.net</span><br><span class="line"> * centos-sclo-sclo: mirrors.sonic.net</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">centos-sclo-rh&#x2F;x86_64&#x2F;filelists_db                                                                                                    |  12 MB  00:00:01     </span><br><span class="line">centos-sclo-sclo&#x2F;x86_64&#x2F;filelists_db                                                                                                  | 917 kB  00:00:00     </span><br><span class="line">epel&#x2F;x86_64&#x2F;filelists_db                                                                                                              |  12 MB  00:00:00     </span><br><span class="line">kernel-debug-devel-3.10.0-1062.el7.x86_64 : Development package for building kernel modules to match the debug kernel</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.el7.x86_64.debug&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-debug-devel-3.10.0-1062.1.1.el7.x86_64 : Development package for building kernel modules to match the debug kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.1.1.el7.x86_64.debug&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-debug-devel-3.10.0-1062.1.2.el7.x86_64 : Development package for building kernel modules to match the debug kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.1.2.el7.x86_64.debug&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-debug-devel-3.10.0-1062.4.1.el7.x86_64 : Development package for building kernel modules to match the debug kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.4.1.el7.x86_64.debug&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-debug-devel-3.10.0-1062.4.2.el7.x86_64 : Development package for building kernel modules to match the debug kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.4.2.el7.x86_64.debug&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-debug-devel-3.10.0-1062.4.3.el7.x86_64 : Development package for building kernel modules to match the debug kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.4.3.el7.x86_64.debug&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-debug-devel-3.10.0-1062.7.1.el7.x86_64 : Development package for building kernel modules to match the debug kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.7.1.el7.x86_64.debug&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-debug-devel-3.10.0-1062.9.1.el7.x86_64 : Development package for building kernel modules to match the debug kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.9.1.el7.x86_64.debug&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-devel-3.10.0-1062.el7.x86_64 : Development package for building kernel modules to match the kernel</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.el7.x86_64&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-devel-3.10.0-1062.1.1.el7.x86_64 : Development package for building kernel modules to match the kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.1.1.el7.x86_64&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-devel-3.10.0-1062.1.2.el7.x86_64 : Development package for building kernel modules to match the kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.1.2.el7.x86_64&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-devel-3.10.0-1062.4.1.el7.x86_64 : Development package for building kernel modules to match the kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.4.1.el7.x86_64&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-devel-3.10.0-1062.4.2.el7.x86_64 : Development package for building kernel modules to match the kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.4.2.el7.x86_64&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-devel-3.10.0-1062.4.3.el7.x86_64 : Development package for building kernel modules to match the kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.4.3.el7.x86_64&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-devel-3.10.0-1062.7.1.el7.x86_64 : Development package for building kernel modules to match the kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.7.1.el7.x86_64&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-devel-3.10.0-1062.9.1.el7.x86_64 : Development package for building kernel modules to match the kernel</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.9.1.el7.x86_64&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-headers-3.10.0-1062.el7.x86_64 : Header files for the Linux kernel for use by glibc</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;include&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-headers-3.10.0-1062.1.1.el7.x86_64 : Header files for the Linux kernel for use by glibc</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;include&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-headers-3.10.0-1062.1.2.el7.x86_64 : Header files for the Linux kernel for use by glibc</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;include&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-headers-3.10.0-1062.4.1.el7.x86_64 : Header files for the Linux kernel for use by glibc</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;include&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-headers-3.10.0-1062.4.2.el7.x86_64 : Header files for the Linux kernel for use by glibc</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;include&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-headers-3.10.0-1062.4.3.el7.x86_64 : Header files for the Linux kernel for use by glibc</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;include&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-headers-3.10.0-1062.7.1.el7.x86_64 : Header files for the Linux kernel for use by glibc</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;include&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-headers-3.10.0-1062.9.1.el7.x86_64 : Header files for the Linux kernel for use by glibc</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;include&#x2F;linux&#x2F;limits.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel-devel-3.10.0-1062.9.1.el7.x86_64 : Development package for building kernel modules to match the kernel</span><br><span class="line">Repo        : @updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-1062.9.1.el7.x86_64&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;limits.h</span><br></pre></td></tr></table></figure>

<p>然后从这些包里选一个（建议新版本的），安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install kernel-headers-3.10.0-1062.4.1.el7.x86_64</span><br></pre></td></tr></table></figure>

<p>再次运行gcc，就不会提示错误了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(22) - 网络编程</title>
    <url>/2020/02/03/Linux%20%5B22%5D%20-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><h3 id="fd是什么"><a href="#fd是什么" class="headerlink" title="fd是什么"></a>fd是什么</h3><p>fd全称是file descriptor,是进程独有的文件描述符表的索引。</p>
<h3 id="socket类型"><a href="#socket类型" class="headerlink" title="socket类型"></a>socket类型</h3><p>1)流式socket(SOCK_STREAM) -&gt;用于TCP 通信</p>
<p>2)数据报socket(SOCK_DGRAM) -&gt;用于UDP 通信<a id="more"></a></p>
<p>3)原始socket(SOCK_RAW) -&gt;用于用于新的网络协议实现的测试等</p>
<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/*14 字节的协议地址，包含该socket 的IP 地址和端口号。*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实际编程中使用下面这个更方便的接口：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">	short <span class="keyword">int</span> sin_family; <span class="comment">/*地址族*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> short <span class="keyword">int</span> sin_port; <span class="comment">/*端口号*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*IP 地址*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/*填充0 以保持与struct sockaddr 同样大小*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sin_family:</span></span><br><span class="line"><span class="comment"> AF_INET  = IPv4 协议</span></span><br><span class="line"><span class="comment"> AF_INET6 = IPv6 协议</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">	<span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="数据存储优先顺序（大小端）的转换"><a href="#数据存储优先顺序（大小端）的转换" class="headerlink" title="数据存储优先顺序（大小端）的转换"></a>数据存储优先顺序（大小端）的转换</h2><ul>
<li><p>主机字节序：小端模式(Intel)</p>
</li>
<li><p>网络字节序：大端模式</p>
<p>在网络上进行通信，则数据必须转化为网络字节序</p>
<p>实现网络字节序和主机字节序的转，用到的函数有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> htons();</span><br><span class="line"> <span class="comment">//将无符号短整型数转换为网络字节序</span></span><br><span class="line"> ntohs();</span><br><span class="line"> <span class="comment">//将无符号短整型数转换为主机字节序</span></span><br><span class="line"> htonl();</span><br><span class="line"> <span class="comment">//将无符号长整形数转换位网络字节序</span></span><br><span class="line"> ntohl();</span><br><span class="line"> <span class="comment">//将无符号短整型数转换为主机字节序</span></span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">	h = host</span><br><span class="line">	n = network</span><br><span class="line">	s = short</span><br><span class="line">	l = <span class="keyword">long</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="地址格式转化"><a href="#地址格式转化" class="headerlink" title="地址格式转化"></a>地址格式转化</h2><p>+点分十进制和32位网络字节序相互转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//点分十进制IP地址转换为32位网络字节序</span></span><br><span class="line"><span class="comment">//ipv4:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *straddr, struct in_addr *addrptr)</span></span>;	</span><br><span class="line"><span class="comment">//成功返回1，不成功返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *straddr)</span>	</span></span><br><span class="line"><span class="function"><span class="comment">//成功返回32位网络字节序地址 </span></span></span><br><span class="line"><span class="function"><span class="comment">//straddr：存放输入的点分十进制数IP 地址字符串。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//ipv4/6:</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">//family: AF_INET = IPv4协议 ; AF_INET6 = IPv6 协议。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//32位网络字节序转换为点分十进制IP地址:</span></span><br><span class="line"><span class="comment">//ipv4:</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4/6:</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="名字地址转化"><a href="#名字地址转化" class="headerlink" title="名字地址转化"></a>名字地址转化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *h_name; 		<span class="comment">/*正式主机名*/</span></span><br><span class="line"><span class="keyword">char</span> **h_aliases;   <span class="comment">/*主机别名*/</span></span><br><span class="line"><span class="keyword">int</span> h_addrtype;     <span class="comment">/*主机IP地址类型IPv4 为AF_INET*/</span></span><br><span class="line"><span class="keyword">int</span> h_length;       <span class="comment">/*主机IP地址字节长度，IPv4  = 4 字节*/</span></span><br><span class="line"><span class="keyword">char</span> **h_addr_list; <span class="comment">/*主机的IP地址列表*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主机名（或域名）转化为IP地址：</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IP地址转化为主机名：</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PS：需要联网</span></span><br></pre></td></tr></table></figure>

<h1 id="socket-编程"><a href="#socket-编程" class="headerlink" title="socket 编程"></a>socket 编程</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 通信的基本步骤如下：</p>
<p>server：<br>socket–bind–listen–while(1){accept—recv—send–close}–close</p>
<p>client：<br>socket————————-connect–send—recv——- –close</p>
<ul>
<li>用到的头文件：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h4><ul>
<li>作用：<br>创建一个socket。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">domain: AF_INET = Ipv4</span></span><br><span class="line"><span class="comment">	    AF_INET6 = IPv6</span></span><br><span class="line"><span class="comment">type:   SOCK_STREAM = TCP</span></span><br><span class="line"><span class="comment">		SOCK_DGRAM  = UDP</span></span><br><span class="line"><span class="comment">   protocol: 通常为0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回值：成功返回套接口描述符，失败返回-1。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">ERROR_CHECK(socketFd, <span class="string">"socket"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><ul>
<li>作用：<br>将一个socket绑定到一个地址上。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd:前面socket 的返回值。</span></span><br><span class="line"><span class="comment">	my_addr:结构体指针变量</span></span><br><span class="line"><span class="comment">	addrlen:sockaddr的结构体长度。通常是计算sizeof(struct sockaddr);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	对于不同的socket domain 定义了一个通用的数据结构struct sockaddr</span></span><br><span class="line"><span class="comment">	此结构会因使用不同的socket domain 而有不同结构定义，</span></span><br><span class="line"><span class="comment">	例如使用AF_INET domain，其socketaddr 结构定义便为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> //此结构体不常用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short <span class="keyword">int</span> sa_family; <span class="comment">//调用socket()时的domain参数，即AF_INET值。</span></span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">//最多使用14个字符长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> //常用的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short <span class="keyword">int</span> sin_family; <span class="comment">//sa_family (AF_INET)</span></span><br><span class="line">	<span class="keyword">uint16_t</span> sin_port; <span class="comment">//使用的port 编号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//IP地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">//未使用</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span> <span class="comment">//定义结构体变量</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr)); <span class="comment">//将结构体清空</span></span><br><span class="line">	<span class="comment">//或bzero(&amp;my_addr, sizeof(struct sockaddr));</span></span><br><span class="line">my_addr.sin_family = AF_INET; <span class="comment">//采用Ipv4</span></span><br><span class="line">my_addr.sin_port = htons(<span class="number">2000</span>); <span class="comment">//端口号设为2000，通常大于1024</span></span><br><span class="line">	<span class="comment">//htons()用来将参数指定的16 位hostshort 转换成网络字符顺序</span></span><br><span class="line">my_addr.sin_addr.s_addr = inet_addr(<span class="string">"192.168.0.101"</span>); </span><br><span class="line">	<span class="comment">//inet_addr()用来将IP 地址字符串转换成网络所使用的二进制数字，如果为INADDR_ANY，这表示服务器自动填充本机IP。 </span></span><br><span class="line">bind(sockfd, (struct sockaddr*)&amp;my_str, <span class="keyword">sizeof</span>(struct socketaddr);</span><br><span class="line">ERROR_CHECK(bind, <span class="number">-1</span>, <span class="string">"bind"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	通过将my_addr.sin_port 置为0，函数会自动为你选择一个未占用的端口来使用。</span></span><br><span class="line"><span class="comment">	同样，通过将my_addr.sin_addr.s_addr 置为INADDR_ANY，系统会自动填入本机IP 地址</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><ul>
<li>作用：<br>使服务器的这个端口和IP 处于监听状态，等待网络中某一客户机的连接请求。如果客户<br>端有连接请求，端口就会接受这个连接。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd: 前面socket的返回值</span></span><br><span class="line"><span class="comment">	backlog：指定同时能处理的最大连接要求，通常为10 或者5。最大值可设至128</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：成功则返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = <span class="built_in">listen</span>(sockfd, <span class="number">10</span>);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"listen"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><ul>
<li>作用：</li>
</ul>
<ol>
<li><p>接受远程计算机的连接请求，建立起与客户机之间的通信连接。</p>
</li>
<li><p>服务器处于监听状态时，如果某时刻获得客户机的连接请求，此时并不是立即处理这个请求，而是将这个请求放在等待队列中，<br>当系统空闲时再处理客户机的连接请求。</p>
</li>
<li><p>当accept 函数接受一个连接时，会返回一个新的socket 标识符，<br>以后的数据传输和读取就要通过这个新的socket 编号来处理，原来参数中的socket 也可以继续使用，继续监听其它客户机的连接请求。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * addr, <span class="keyword">socklen_t</span> * addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd: 前面socket的返回值</span></span><br><span class="line"><span class="comment">	addr: 结构体指针变量，系统会把远程主机的信息（远程主机的地址和端口号信息）保存到这个指针所指的结构体中。</span></span><br><span class="line"><span class="comment">	addrlen: 表示结构体的长度，为整型指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：成功则返回新的socket 处理代码new_fd，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;clientaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line"><span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"><span class="keyword">int</span> new_fd = accept(sfd, (struct sockaddr*)&amp;clientaddr, &amp;addrlen);</span><br><span class="line">ERROR_CHECK(new_fd, <span class="number">-1</span>, <span class="string">"accept"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %d success connect\n"</span>,inet_ntoa(clientaddr.sin_addr),ntohs(clientaddr.sin_port));</span><br></pre></td></tr></table></figure>

<h4 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h4><ul>
<li>作用：<br>用新的套接字来接收远端主机传来的数据，并把数据存到由参数buf 指向的内存空间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd: 前面accept 的返回值.即new_fd</span></span><br><span class="line"><span class="comment">	buf: 缓冲区</span></span><br><span class="line"><span class="comment">	len: 表示缓冲区的长度</span></span><br><span class="line"><span class="comment">	flags:通常为0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值: 成功返回实际接收到的字符数，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">ret = recv(new_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"recv"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><ul>
<li>作用：<br>用新的套接字发送数据给指定的远端主机</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">const</span> <span class="keyword">void</span> * msg,<span class="keyword">int</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	s:前面accept 的返回值.即new_fd</span></span><br><span class="line"><span class="comment">	msg: 常量字符串</span></span><br><span class="line"><span class="comment">	len: 长度</span></span><br><span class="line"><span class="comment">	flags: 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值: 成功返回实际传送出去的字符数，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = send(new_fd, <span class="string">"hello"</span>, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"send"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>+作用：<br>：当使用完文件后若已不再需要则可使用close()关闭该文件，并且close()会让数据写回磁盘，并释放该文件所占用的资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	fd：为前面的sfd,new_fd</span></span><br><span class="line"><span class="comment">	返回值：若文件顺利关闭返回0，发生错误返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(new_fd);</span><br><span class="line"><span class="built_in">close</span>(sfd);</span><br></pre></td></tr></table></figure>

<p>可以调用shutdown 实现半关闭：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><ul>
<li>作用：<br>用来请求连接远程服务器，将参数sockfd的socket连至参数serv_addr 指定的服务器IP和端口号上去。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * serv_addr, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd：为前面的socketsocket的返回值，即sfd</span></span><br><span class="line"><span class="comment">	serv_addr: 为结构体指针变量，存储着远程服务器的IP 与端口号信息。</span></span><br><span class="line"><span class="comment">	addrlen: 表示结构体变量的长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值: 成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span><span class="comment">//请求连接服务器</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">seraddr.sin_family = AF_INET;</span><br><span class="line">seraddr.sin_port = htons(<span class="number">2000</span>); <span class="comment">//服务器的端口号</span></span><br><span class="line">seraddr.sin_addr.s_addr = inet_addr(<span class="string">"192.168.0.101"</span>); <span class="comment">//服务器的ip</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">connect</span>(sfd, (struct sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"connect"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="socket，send-recv-close-同server"><a href="#socket，send-recv-close-同server" class="headerlink" title="socket，send, recv, close 同server"></a>socket，send, recv, close 同server</h4><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><p>tcp_server.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="comment">//初始化一个socket，有一个缓冲区</span></span><br><span class="line">    socketFd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);                                       </span><br><span class="line">    ERROR_CHECK(socketFd,<span class="number">-1</span>,<span class="string">"socket"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socketFd=%d\n"</span>,socketFd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser</span>;</span></span><br><span class="line">    bzero(&amp;ser,<span class="keyword">sizeof</span>(ser));</span><br><span class="line">    ser.sin_family=AF_INET;</span><br><span class="line">    ser.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    ser.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret=bind(socketFd,(struct sockaddr *)&amp;ser,<span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"bind"</span>);</span><br><span class="line">    <span class="built_in">listen</span>(socketFd,<span class="number">10</span>);<span class="comment">//端口激活</span></span><br><span class="line">    <span class="keyword">int</span> new_fd;<span class="comment">//用来保存新建连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span><span class="comment">//从内核拿出对方的socket信息</span></span><br><span class="line">    bzero(&amp;client,<span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(client);</span><br><span class="line">    new_fd=accept(socketFd,(struct sockaddr *)&amp;client,&amp;len);</span><br><span class="line">    ERROR_CHECK(new_fd,<span class="number">-1</span>,<span class="string">"accept"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip=%s,client port=%d\n"</span>,inet_ntoa(client.sin_addr),ntohs(client</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">int</span> readyFdNum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO,&amp;rdset);</span><br><span class="line">        FD_SET(new_fd,&amp;rdset);</span><br><span class="line">        readyFdNum=select(new_fd+<span class="number">1</span>,&amp;rdset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(readyFdNum&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(new_fd,&amp;rdset))</span><br><span class="line">            &#123;</span><br><span class="line">                bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret=recv(new_fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(!ret)<span class="comment">//对方断开了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"byebye\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO,&amp;rdset))</span><br><span class="line">            &#123;</span><br><span class="line">                bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                send(new_fd,buf,<span class="built_in">strlen</span>(buf)<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line">    <span class="built_in">close</span>(socketFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcp_server.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="comment">//初始化一个socket，有一个缓冲区</span></span><br><span class="line">    socketFd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socketFd,<span class="number">-1</span>,<span class="string">"socket"</span>);                                            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socketFd=%d\n"</span>,socketFd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser</span>;</span></span><br><span class="line">    bzero(&amp;ser,<span class="keyword">sizeof</span>(ser));</span><br><span class="line">    ser.sin_family=AF_INET;</span><br><span class="line">    ser.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    ser.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret=bind(socketFd,(struct sockaddr *)&amp;ser,<span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"bind"</span>);</span><br><span class="line">    <span class="built_in">listen</span>(socketFd,<span class="number">10</span>);<span class="comment">//端口激活</span></span><br><span class="line">    <span class="keyword">int</span> new_fd;<span class="comment">//用来保存新建连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span><span class="comment">//从内核拿出对方的socket信息</span></span><br><span class="line">    bzero(&amp;client,<span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(client);</span><br><span class="line">    new_fd=accept(socketFd,(struct sockaddr *)&amp;client,&amp;len);</span><br><span class="line">    ERROR_CHECK(new_fd,<span class="number">-1</span>,<span class="string">"accept"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip=%s,client port=%d\n"</span>,inet_ntoa(client.sin_addr),ntohs(client</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">int</span> readyFdNum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO,&amp;rdset);</span><br><span class="line">        FD_SET(new_fd,&amp;rdset);</span><br><span class="line">        readyFdNum=select(new_fd+<span class="number">1</span>,&amp;rdset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(readyFdNum&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(new_fd,&amp;rdset))</span><br><span class="line">            &#123;</span><br><span class="line">                bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret=recv(new_fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(!ret)<span class="comment">//对方断开了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"byebye\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO,&amp;rdset))</span><br><span class="line">            &#123;</span><br><span class="line">                bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                send(new_fd,buf,<span class="built_in">strlen</span>(buf)<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line">    <span class="built_in">close</span>(socketFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 通信流程图如下：</p>
<p>server：<br>socket–bind–recvfrom—sendto–close<br>client：<br>socket——–sendto—recvfrom–close </p>
<p>udp无连接，不需要考虑连接和退出问题。</p>
<h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h3><p>+作用： 等同于tcp的recv，但ucp执行sendto前必须先执行一次recvfrom。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags,struct sockaddr *from,<span class="keyword">int</span> *fromlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    比recv多两个参数：</span></span><br><span class="line"><span class="comment">    from: 保存连接机的IP 地址及端口号。</span></span><br><span class="line"><span class="comment">    fromlen: 常置为sizeof(struct sockaddr)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    返回值: 正确时返回接收到的字节数；错误时返回-1，并置相应的errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h3><p>+作用： 等同于tcp的send。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *msg,<span class="keyword">int</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags,<span class="keyword">const</span> struct sockaddr *to, <span class="keyword">int</span> tolen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    比recv多两个参数：</span></span><br><span class="line"><span class="comment">    to: 表示目地机的IP 地址和端口号信息</span></span><br><span class="line"><span class="comment">    tolen: 常常被赋值为sizeof (struct sockaddr)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    返回值: 返回实际发送的数据字节长度，错误时返回-1。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="UDP实例代码"><a href="#UDP实例代码" class="headerlink" title="UDP实例代码"></a>UDP实例代码</h3><ul>
<li>用UDP实现客户端和服务器端各发一句话:</li>
</ul>
<p>udp_server.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);  <span class="comment">// 2个参数分别为ip和端口号    </span></span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    socketFd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">    ERROR_CHECK(socketFd, <span class="number">-1</span>, <span class="string">"socket"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socketFd = %d\n"</span>, socketFd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser</span>;</span></span><br><span class="line">    bzero(&amp;ser, <span class="keyword">sizeof</span>(ser));</span><br><span class="line">    ser.sin_family = AF_INET;</span><br><span class="line">    ser.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    ser.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);<span class="comment">//ip地址转网络字节序</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = bind(socketFd, (struct sockaddr *)&amp;ser, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"bind"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    bzero(&amp;client, <span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">    recvfrom(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip=%s,client port=%d\n"</span>,inet_ntoa(client.sin_addr),ntohs(client.sin_port));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    sendto(socketFd, <span class="string">"I am server."</span>, <span class="number">10</span>, <span class="number">0</span>, (struct sockaddr*)&amp;client, <span class="keyword">sizeof</span>(client));                                                                                                    </span><br><span class="line">    <span class="built_in">close</span>(socketFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>udp_client.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);  <span class="comment">// 2个参数分别为ip和端口号    </span></span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    socketFd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);                                                                                                                                            </span><br><span class="line">    ERROR_CHECK(socketFd, <span class="number">-1</span>, <span class="string">"socket"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socketFd = %d\n"</span>, socketFd);    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser</span>;</span></span><br><span class="line">    bzero(&amp;ser, <span class="keyword">sizeof</span>(ser));</span><br><span class="line">    ser.sin_family = AF_INET;</span><br><span class="line">    ser.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    ser.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">"Hi, I am client."</span>;</span><br><span class="line">    sendto(socketFd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (struct sockaddr*)&amp;ser, <span class="keyword">sizeof</span>(ser));</span><br><span class="line">    recvfrom(socketFd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//知道是从服务器接收，可以置为NULL,即从内核中读取</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    <span class="built_in">close</span>(socketFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h2><ul>
<li>作用: 设置socket属性。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd：标识一个套接口的描述字</span></span><br><span class="line"><span class="comment">	level：选项定义的层次；支持</span></span><br><span class="line"><span class="comment">	optname：需设置的选项</span></span><br><span class="line"><span class="comment">	optval：指针，指向存放选项值的缓冲区</span></span><br><span class="line"><span class="comment">	optlen：optval 缓冲区长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>level有四个层次，分别是SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP 和IPPROTO_IPV6。<br>不同层次下optname：</p>
<ul>
<li>level: SOL_SOCKET</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>SO_BROADCAST</td>
<td>允许发送广播数据</td>
<td>int</td>
</tr>
<tr>
<td>SO_DEBUG</td>
<td>允许调试</td>
<td>int</td>
</tr>
<tr>
<td>SO_DONTROUTE</td>
<td>不查找路由</td>
<td>int</td>
</tr>
<tr>
<td>SO_ERROR</td>
<td>获得套接字错误</td>
<td>int</td>
</tr>
<tr>
<td>SO_KEEPALIVE</td>
<td>保持连接</td>
<td>int</td>
</tr>
<tr>
<td>SO_LINGER</td>
<td>延迟关闭连接</td>
<td>struct linger</td>
</tr>
<tr>
<td>SO_OOBINLINE</td>
<td>带外数据放入正常数据流</td>
<td>int</td>
</tr>
<tr>
<td>SO_RCVBUF</td>
<td>接收缓冲区大小</td>
<td>int</td>
</tr>
<tr>
<td>SO_SNDBUF</td>
<td>发送缓冲区大小</td>
<td>int</td>
</tr>
<tr>
<td>SO_RCVLOWAT</td>
<td>接收缓冲区下限</td>
<td>int</td>
</tr>
<tr>
<td>SO_SNDLOWAT</td>
<td>发送缓冲区下限</td>
<td>int</td>
</tr>
<tr>
<td>SO_RCVTIMEO</td>
<td>接收超时</td>
<td>struct timeval</td>
</tr>
<tr>
<td>SO_SNDTIMEO</td>
<td>发送超时</td>
<td>struct timeval</td>
</tr>
<tr>
<td>SO_REUSEADDR</td>
<td>允许重用本地地址和端口</td>
<td>int</td>
</tr>
<tr>
<td>SO_TYPE</td>
<td>获得套接字类型</td>
<td>int</td>
</tr>
<tr>
<td>SO_BSDCOMPAT</td>
<td>与BSD</td>
<td>系统兼容</td>
</tr>
</tbody></table>
<hr>
<ul>
<li>level: IPPROTO_IP</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>IP_HDRINCL</td>
<td>在数据包中包含IP首部</td>
<td>int</td>
</tr>
<tr>
<td>IP_OPTINOS</td>
<td>IP首部选项</td>
<td>int</td>
</tr>
<tr>
<td>IP_TOS</td>
<td>服务类型</td>
<td></td>
</tr>
<tr>
<td>IP_TTL</td>
<td>生存时间</td>
<td>int</td>
</tr>
</tbody></table>
<hr>
<ul>
<li>level: IPPRO_TCP</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>TCP_MAXSEG</td>
<td>TCP最大数据段的大小</td>
<td>int</td>
</tr>
<tr>
<td>TCP_NODELAY</td>
<td>不使用Nagle算法</td>
<td>int</td>
</tr>
</tbody></table>
<h2 id="EPOLL多路复用"><a href="#EPOLL多路复用" class="headerlink" title="EPOLL多路复用"></a>EPOLL多路复用</h2><h3 id="epoll和select的区别"><a href="#epoll和select的区别" class="headerlink" title="epoll和select的区别"></a>epoll和select的区别</h3><ol>
<li>epoll支持水平触发和边缘触发，select只支持水平触发。</li>
<li>epoll可监控的文件描述符数量没有上限</li>
</ol>
<p>epoll 操作过程需要三个接口，分别如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt; //epoll需要的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建一个epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>现在size填1即可，表示监控的数目不限。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">//epoll 的事件注册函数，不同于select的传入传出参数，一次注册永久生效</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	epfd: epoll_create()的返回值，</span></span><br><span class="line"><span class="comment">	op: 表示动作</span></span><br><span class="line"><span class="comment">	fd: 需要监听的fd</span></span><br><span class="line"><span class="comment">	event: 告诉内核需要监听什么事</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//struct epoll_event 结构如下：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="keyword">_uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>op用以下三个宏来表示：<br>EPOLL_CTL_ADD：注册新的fd 到epfd 中；<br>EPOLL_CTL_MOD：修改已经注册的fd 的监听事件；<br>EPOLL_CTL_DEL：从epfd 中删除一个fd；</p>
</li>
<li><p>events可以是以下几个宏的集合：<br>  EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET 正常关闭）；<br>  EPOLLOUT：表示对应的文件描述符可以写；<br>  EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>  EPOLLERR：表示对应的文件描述符发生错误；<br>  EPOLLHUP：表示对应的文件描述符被挂断；<br>  EPOLLET： 将EPOLL 设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>  EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket 的话，需要再次把这个socket 加入到EPOLL 队列里</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    maxevents: 告知内核这个events有多大，不能大于创建epoll_create()时的size。</span></span><br><span class="line"><span class="comment">    timeout: 超时时间（毫秒，0会立即返回，-1将一直阻塞，直到等待列表的文件描述符有事件产生）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>用法：</p>
<p>tcp_sever_epoll.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="comment">//初始化一个socket，有一个缓冲区</span></span><br><span class="line">    socketFd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socketFd,<span class="number">-1</span>,<span class="string">"socket"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socketFd=%d\n"</span>,socketFd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser</span>;</span></span><br><span class="line">    bzero(&amp;ser,<span class="keyword">sizeof</span>(ser));</span><br><span class="line">    ser.sin_family=AF_INET;</span><br><span class="line">    ser.sin_port=htons(atoi(argv[<span class="number">2</span>]));                                                  </span><br><span class="line">    ser.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> reuse=<span class="number">1</span>;</span><br><span class="line">    ret=setsockopt(socketFd,SOL_SOCKET,SO_REUSEADDR,&amp;reuse,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"setsockopt"</span>);</span><br><span class="line">    ret=bind(socketFd,(struct sockaddr *)&amp;ser,<span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"bind"</span>);</span><br><span class="line">    <span class="built_in">listen</span>(socketFd,<span class="number">10</span>);<span class="comment">//端口激活</span></span><br><span class="line">    <span class="keyword">int</span> new_fd;<span class="comment">//用来保存新建连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span><span class="comment">//从内核拿出对方的socket信息</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> epfd=epoll_create(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//注册两个描述符，0，new_fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>,<span class="title">evs</span>[3];</span></span><br><span class="line">    event.data.fd=STDIN_FILENO;</span><br><span class="line">    event.events=EPOLLIN;</span><br><span class="line">    ret=epoll_ctl(epfd,EPOLL_CTL_ADD,STDIN_FILENO,&amp;event);</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"epoll_ctl"</span>);</span><br><span class="line">    event.data.fd=socketFd;</span><br><span class="line">    ret=epoll_ctl(epfd,EPOLL_CTL_ADD,socketFd,&amp;event);</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"epoll_ctl"</span>);</span><br><span class="line">    <span class="keyword">int</span> readyFdNum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        readyFdNum=epoll_wait(epfd,evs,<span class="number">3</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;readyFdNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd==socketFd)<span class="comment">//新用户连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                bzero(&amp;client,<span class="keyword">sizeof</span>(client));</span><br><span class="line">                <span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(client);</span><br><span class="line">                new_fd=accept(socketFd,(struct sockaddr *)&amp;client,&amp;len);</span><br><span class="line">                ERROR_CHECK(new_fd,<span class="number">-1</span>,<span class="string">"accept"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"client ip=%s,client port=%d\n"</span>,inet_ntoa(client.sin_addr),ntohs(</span><br><span class="line">                <span class="comment">//监控new_fd</span></span><br><span class="line">                event.data.fd=new_fd;</span><br><span class="line">                ret=epoll_ctl(epfd,EPOLL_CTL_ADD,new_fd,&amp;event);</span><br><span class="line">                ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"epoll_ctl"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd==new_fd)</span><br><span class="line">            &#123; </span><br><span class="line">              bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret=recv(new_fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(!ret)<span class="comment">//对方断开了,让它再连</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"byebye\n"</span>);</span><br><span class="line">                    event.data.fd=new_fd;</span><br><span class="line">                    epoll_ctl(epfd,EPOLL_CTL_DEL,new_fd,&amp;event);</span><br><span class="line">                    <span class="built_in">close</span>(new_fd);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd==STDIN_FILENO)</span><br><span class="line">            &#123;</span><br><span class="line">                bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                send(new_fd,buf,<span class="built_in">strlen</span>(buf)<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">end</span>:</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line">    <span class="built_in">close</span>(socketFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之环境变量PS1</title>
    <url>/2020/02/01/Linux%5B2%5D%20-%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FPS1/</url>
    <content><![CDATA[<h1 id="1-PS1是什么"><a href="#1-PS1是什么" class="headerlink" title="1.PS1是什么"></a>1.PS1是什么</h1><p>PS1是Linux终端用户的一个环境变量，用来定义命令行提示符的参数。<a id="more"></a><br>输入命令<br><code>$ echo $PS1</code><br>可得到当前定义的PS1值<br><code>\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$</code></p>
<h1 id="2-PS1参数"><a href="#2-PS1参数" class="headerlink" title="2.PS1参数"></a>2.PS1参数</h1><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　\d ：代表日期，格式为weekday month date，例如：&quot;Mon Aug 1&quot;</span><br><span class="line"></span><br><span class="line">　　\H ：完整的主机名称</span><br><span class="line"></span><br><span class="line">　　\h ：仅取主机名中的第一个名字</span><br><span class="line"></span><br><span class="line">　　\t ：显示时间为24小时格式，如：HH：MM：SS</span><br><span class="line"></span><br><span class="line">　　\T ：显示时间为12小时格式</span><br><span class="line"></span><br><span class="line">　　\A ：显示时间为24小时格式：HH：MM</span><br><span class="line"></span><br><span class="line">　　\u ：当前用户的账号名称</span><br><span class="line"></span><br><span class="line">　　\v ：BASH的版本信息</span><br><span class="line"></span><br><span class="line">　　\w ：完整的工作目录名称</span><br><span class="line"></span><br><span class="line">　　\W ：利用basename取得工作目录名称，只显示最后一个目录名</span><br><span class="line"></span><br><span class="line">　　\# ：下达的第几个命令</span><br><span class="line"></span><br><span class="line">　　\$ ：提示字符，如果是root用户，提示符为 # ，普通用户则为 $</span><br></pre></td></tr></table></figure>
<p>所以linux默认的命令行提示信息的格式<br><code>PS1=&#39;[\u@\h \W]\$ &#39;</code>  的意思就是：<br>[当前用户的账号名称@主机名的第一个名字 工作目录的最后一层目录名]#</p>
<p>##颜色设置参数<br>　在PS1中设置字符颜色的格式为：<code>\[\e[F;Bm\]........\[\e[0m\]</code><br>其中“F“为字体颜色，编号为30-37，“B”为背景颜色，编号为40-47,<code>\[\e[0m\]</code>作为颜色设定的结束。<br>　　颜色对照表：</p>
<p>　　　　F    B</p>
<p>　　　　30  40 黑色</p>
<p>　　　　31  41 红色</p>
<p>　　　　32  42 绿色</p>
<p>　　　　33  43 黄色</p>
<p>　　　　34  44 蓝色</p>
<p>　　　　35  45 紫红色</p>
<p>　　　　36  46 青蓝色</p>
<p>　　　　37  47 白色</p>
<p>修改颜色，只需将对应数字套入设置格式中即可。</p>
<p>比如要设置命令行的格式为绿字黑底([\e[32;40m])，显示当前用户的账号名称(\u)、主机的第一个名字(\h)、完整的当前工作目录名称(\w)、24小时格式时间(\t)，可以直接在命令行键入如下命令：<br><code>$ PS1=&#39;[\[\e[32;40m\]\u@\h \w \t]$ \[\e[0m\]&#39;</code><br>用以上方法修改PS1变量只是临时性的，下次登录即恢复原样。</p>
<h1 id="3-修改-bashrc文件-永久保存命令行样式"><a href="#3-修改-bashrc文件-永久保存命令行样式" class="headerlink" title="3.修改.bashrc文件,永久保存命令行样式"></a>3.修改.bashrc文件,永久保存命令行样式</h1><p>在家目录下使用ls -la命令即可看到.bashrc这个文件</p>
<p>编辑.bashrc文件，加入这一行：(以下是本人的设置)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PS1&#x3D;&quot;\[\e[31;1m\]\u@\[\e[34;1m\]\h \[\e[36;1m\]\w $\[\e[37;1m\] &quot;</span><br></pre></td></tr></table></figure>

<p>保存退出，然后重新加载bash配置文件:</p>
<p><code>$ source .bashrc</code></p>
<p>即可永久生效。<br>———<br>参考来源 <a href="https://www.cnblogs.com/Q--T/p/5394993.html" target="_blank" rel="noopener">https://www.cnblogs.com/Q--T/p/5394993.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(10) - time</title>
    <url>/2020/02/01/Linux%5B10%5D%20-%20time/</url>
    <content><![CDATA[<p>Linux中有如下几个显示时间的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *tloc)</span></span>;</span><br><span class="line"><span class="comment">//当前距离1970年1月1日00点00分00秒的秒数</span></span><br><span class="line"><span class="comment">//time_t = long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *timep)</span></span>;</span><br><span class="line"><span class="comment">//将秒数转换为字符串形式：星期 月 日 时间 年</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *timep)</span></span>;</span><br><span class="line"><span class="comment">//格林尼治时间</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(21) - 多线程</title>
    <url>/2020/01/29/Linux%5B21%5D%20-%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程是系统中程序执行和资源分配的基本单位。</p>
<p>线程是在共享内存空间中并发执行的多道执行路径，是进程的基本调度单元，一个进程内可拥有多个线程。（程序执行路径即函数栈的弹栈压栈过程）</p>
<p>它与同进程中的其他线程共享进程空间、<a id="more"></a>堆、代码、数据、文件描述符、信号等，只拥有自己的栈空间，大大减少了上下文切换的开销。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>线程和进程在使用上各有优缺点：</p>
<p>&emsp;线程执行开销小，占用的CPU少，线程之间的切换快，但不利于资源的管理和保护。</p>
<p>&emsp;进程正相反，从可移植性来讲，多进程的可移植性要好些。</p>
<h1 id="线程的Linux实现"><a href="#线程的Linux实现" class="headerlink" title="线程的Linux实现"></a>线程的Linux实现</h1><p>使用NPTL线程库实现，在编译时要在编译命令后面加-lpthread。</p>
<p>使用到的头文件为&lt;pthread.h&gt;，使用到的接口以pthread_开头。</p>
<p>因为pthread开头的接口，都不能用perror，故在头文件中新定义一个宏 THREAD_ERROR_CHECK 用来检查返回值是否正确：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_ERROR_CHECK(ret,funcName)\</span></span><br><span class="line"> &#123;<span class="keyword">if</span>(ret!=<span class="number">0</span>)\</span><br><span class="line"> &#123;<span class="built_in">printf</span>(<span class="string">"%s:%s\n"</span>,funcName,strerror(ret));<span class="keyword">return</span> <span class="number">-1</span>;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>线程创建采用函数pthread_create, 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, </span></span></span><br><span class="line"><span class="function"><span class="params">	           <span class="keyword">pthread_attr_t</span> * attr, </span></span></span><br><span class="line"><span class="function"><span class="params">	           <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="function"><span class="params">	           <span class="keyword">void</span> * arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>thread: 传出参数，保存新线程的标识（进程id）。</p>
<p>attr: 结构体指针，结构中的元素分别指定新线程的运行属性。通常NULL即可。</p>
<p>start_routine: 函数指针，指向新线程的入口点函数(本文命名为threadFunc)。</p>
<p>arg: 用于传递给start_routine指向的入口点函数（即threadFunc函数）的参数，可以为NULL，表示不传递。即向子进程传递参数时就要用的这个变量。</p>
<p>在64位操作系统中，指针变量占8个字节，若通过arg变量传一个整数，则大小也必须为8个字节（如long类型），int类型只占4字节所以不可用。</p>
<p>通常的形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthid;</span><br><span class="line">pthread_create(&amp;pthid,<span class="literal">NULL</span>,pthfunc,<span class="literal">NULL</span>);      <span class="meta">#arg为NULl时</span></span><br><span class="line">pthread_create(&amp;pthid,<span class="literal">NULL</span>,pthfunc,(<span class="keyword">void</span>*)<span class="number">3</span>);  #将<span class="number">3</span>传给threadFunc的参数p</span><br></pre></td></tr></table></figure>
<h2 id="线程函数-threadFunc"><a href="#线程函数-threadFunc" class="headerlink" title="线程函数 threadFunc"></a>线程函数 threadFunc</h2><p>内容为新线程的执行命令，由程序员自己编写，调用pthread_create创建新线程时，把其第3个参数start_routine填为threadFunc，则新线程的活动即为所写。</p>
<h2 id="线程的退出"><a href="#线程的退出" class="headerlink" title="线程的退出"></a>线程的退出</h2><p>线程退出有两种方式：</p>
<p>&emsp;1.线程从入口点函数自然返回(return 返回值，或执行完全部代码)；</p>
<p>&emsp;2.线程主动调用pthread_exit()函数。</p>
<h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">pthread_exit((<span class="keyword">void</span>*)<span class="number">3</span>);<span class="comment">//3作为返回值被pthread_join函数捕获。</span></span><br></pre></td></tr></table></figure>

<h2 id="线程的等待退出"><a href="#线程的等待退出" class="headerlink" title="线程的等待退出"></a>线程的等待退出</h2><p>若通过pthread_exit函数退出，则其参数可以被其它线程用pthread_join函数捕获。</p>
<h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> pthid, <span class="keyword">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure>
<p>1.该函数是一个阻塞函数，一直等到参数th指定的线程返回,；与多进程中的wait或waitpid类似。</p>
<p>2.<code>thread_return</code>是一个传出参数，接收线程函数的返回值。如果线程通过调用<code>pthread_exit()</code>终止，则<code>pthread_exit()</code>中的参数相当于自然返回值，照样可以被其它线程用<code>pthread_join</code>获取到。</p>
<p>3.该函数还有一个非常重要的作用，由于一个进程中的多个线程共享数据段，因此通常在一个线程退出后，退出线程所占用的资源并不会随线程结束而释放。如果pthid线程类型并不是自动清理资源类型的，则th线程退出后，线程本身的资源必须通过其它线程调用<code>pthread_join()</code>来清除,这相当于多进程程序中的waitpid。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pthread_example1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;func.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"I am child thread\n"</span>);</span><br><span class="line">      p=(<span class="keyword">void</span>*)<span class="number">1</span>;</span><br><span class="line">      pthread_exit(p);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    ret=pthread_create(&amp;pthid,<span class="literal">NULL</span>,threadFunc,<span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret,<span class="string">"pthread_create"</span>);</span><br><span class="line">    <span class="keyword">long</span> threadRetVal;</span><br><span class="line">    ret=pthread_join(pthid,(<span class="keyword">void</span>**)&amp;threadRetVal);</span><br><span class="line">    THREAD_ERROR_CHECK(ret,<span class="string">"pthread_join"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread %ld\n"</span>,threadRetVal);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am child thread</span><br><span class="line">I am main thread 1</span><br></pre></td></tr></table></figure>

<h2 id="线程的取消"><a href="#线程的取消" class="headerlink" title="线程的取消"></a>线程的取消</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<p>线程取消的方法是一个线程向目标线程发cancel信号，但是如何处理cancel信号则由目标线程自己决定，目标线程或者忽略、或者立即终止、或者继续运行至cancelation-point(取消点)后终止。</p>
<h3 id="取消点"><a href="#取消点" class="headerlink" title="取消点"></a>取消点</h3><p>根据POSIX标准，pthread_join()、pthread_testcancel()、pthread_cond_wait()、pthread_cond_timedwait()、sem_wait()、sigwait()等函数以及read()、write()等会引起阻塞的系统调用都是Cancelation-point。</p>
<h2 id="线程终止清理函数"><a href="#线程终止清理函数" class="headerlink" title="线程终止清理函数"></a>线程终止清理函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span></span><br></pre></td></tr></table></figure>
<p><code>pthread_cleanup_push()</code>/<code>pthread_cleanup_pop()</code>采用先入后出的栈结构管理。</p>
<h3 id="pthread-cleanup-pop"><a href="#pthread-cleanup-pop" class="headerlink" title="pthread_cleanup_pop():"></a><code>pthread_cleanup_pop()</code>:</h3><p>调用pthread_cleanup_push()时压入清理函数栈，多次对<code>pthread_cleanup_push()</code>的调用将在清理函数栈中形成一个函数链，在执行该函数链时按照压栈的相反顺序弹出。</p>
<h3 id="pthread-cleanup-pop-1"><a href="#pthread-cleanup-pop-1" class="headerlink" title="pthread_cleanup_pop:"></a><code>pthread_cleanup_pop</code>:</h3><p>其参数execute：</p>
<p>1.如果为非0值,则按栈的顺序注销掉一个原来注册的清理函数，并执行该函数；</p>
<p>2.若为0，仅仅在线程调用pthread_exit函数或者其它线程对本线程调用<code>pthread_cancel</code>函数时，才在弹出“清理函数”的同时执行该“清理函数”。</p>
<h2 id="线程的互斥（动态）"><a href="#线程的互斥（动态）" class="headerlink" title="线程的互斥（动态）"></a>线程的互斥（动态）</h2><p>使用mutex函数来实现线程的互斥。</p>
<p>用到的头文件： &lt;pthread.h&gt;</p>
<h3 id="互斥锁的创建"><a href="#互斥锁的创建" class="headerlink" title="互斥锁的创建"></a>互斥锁的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个互斥锁变量:</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex; </span><br><span class="line"><span class="comment">//初始化互斥锁：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁的注销"><a href="#互斥锁的注销" class="headerlink" title="互斥锁的注销"></a>互斥锁的注销</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。</p>
<p>mutexattr：用于指定互斥锁属性（见下），如果为NULL则使用缺省属性。通常为NULL</p>
<h3 id="互斥锁操作"><a href="#互斥锁操作" class="headerlink" title="互斥锁操作"></a>互斥锁操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//解锁:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>加锁注意事项：</p>
<p>1.如果线程在加锁后解锁前被取消，锁将永远保持锁定状态。因此如果在关键区段内有取消点存在，则必须在退出回调函数<code>pthread_cleanup_push</code>/<code>pthread_cleanup_pop</code>中解锁。</p>
<p>2.若对同一线程连续加锁两次，则会产生死锁。</p>
<h2 id="线程的同步（动态）"><a href="#线程的同步（动态）" class="headerlink" title="线程的同步（动态）"></a>线程的同步（动态）</h2><p>使用条件变量实现线程的同步。</p>
<h3 id="条件变量的创建"><a href="#条件变量的创建" class="headerlink" title="条件变量的创建"></a>条件变量的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond; </span><br><span class="line"><span class="comment">//初始化该条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>cond_attr值通常为NULL。</p>
<h3 id="条件变量的注销"><a href="#条件变量的注销" class="headerlink" title="条件变量的注销"></a>条件变量的注销</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<p>只有在没有线程在该条件变量上等待的时候能注销这个条件变量，否则返回EBUSY。</p>
<h3 id="条件的等待"><a href="#条件的等待" class="headerlink" title="条件的等待"></a>条件的等待</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无条件等待</span></span><br><span class="line">pthread_cond_wait();</span><br><span class="line"><span class="comment">//计时等待</span></span><br><span class="line">pthread_cond_timedwait();</span><br></pre></td></tr></table></figure>
<p>无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()</p>
<h3 id="条件的激发"><a href="#条件的激发" class="headerlink" title="条件的激发"></a>条件的激发</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">激活一个等待该条件的线程，</span></span><br><span class="line"><span class="comment">存在多个等待线程时按入队顺序激活其中一个：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">thread_cond_signal()</span><br><span class="line"><span class="comment">//激活所有等待线程：</span></span><br><span class="line">pthread_cond_broadcast()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(20) - 信号</title>
    <url>/2020/01/28/Linux%5B20%5D%20-%20%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(5) - 文件操作</title>
    <url>/2020/01/27/Linux%5B5%5D%20-%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="基于文件描述符的文件操作"><a href="#基于文件描述符的文件操作" class="headerlink" title="基于文件描述符的文件操作"></a>基于文件描述符的文件操作</h1><p>文件描述符是一个非0的整数。从原理上来说，每次打开文件的时候，进程地址空间的内核部分里面会维护一个已经打开的文件的数组，文件描述符的作用就是这个数组的索引。因此，文件描述符可以实现进程和打开文件之间的交互。<a id="more"></a></p>
<h2 id="文件的创建、打开、和关闭"><a href="#文件的创建、打开、和关闭" class="headerlink" title="文件的创建、打开、和关闭"></a>文件的创建、打开、和关闭</h2><ul>
<li>使用open函数可以打开或者创建并打开一个文件，使用creat函数可以创建一个文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; //头文件 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>; <span class="comment">//文件名 打开方式 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">//文件名 打开方式 权限 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//文件名 权限 </span></span><br><span class="line"><span class="comment">//creat现在已经不常用了，它等价于 </span></span><br><span class="line"><span class="built_in">open</span>(pathname,O_CREAT|O_TRUNC|O_WRONLY,mode);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>open函数的返回值：执行成功时，open函数返回一个文件描述符，表示已经打开的文件；执行失败是，open函数返回-1，并设置相应的errno。</p>
</li>
<li><p>flags和mode都是一组掩码的合成值，flags表示打开或创建的方式，mode表示文件的访问权限。</p>
</li>
<li><p>flags的可选项有：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>掩码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_RDONLY</td>
<td>以只读的方式打开</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>以只写的方式打开</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>以读写的方式打开</td>
</tr>
<tr>
<td>O_CREAT</td>
<td>如果文件不存在，则创建文件</td>
</tr>
<tr>
<td>O_EXCL</td>
<td>仅与O_CREAT连用，如果文件已存在，则open失败</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>如果文件存在，将文件的长度截至0</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>已追加的方式打开文件，每次调用write时，文件指针自动先移到文件尾，用于个文件的情况。</td>
</tr>
<tr>
<td>O_NONBLOCK</td>
<td>非阻塞方式打开，无论有无数据读取或等待，都会立即返回进程之中</td>
</tr>
<tr>
<td>O_NODELAY</td>
<td>非阻塞方式打开</td>
</tr>
<tr>
<td>O_SYNC</td>
<td>同步打开文件，只有在数据被真正写入物理设备设备后才返回</td>
</tr>
</tbody></table>
<ul>
<li><p>mode通常采用直接赋数值的形式，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"file"</span>,O_RDWR | O_CREAT,<span class="number">0755</span>); <span class="comment">//表示给755的权限 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == fd) </span><br><span class="line">	&#123; </span><br><span class="line">		perror(<span class="string">"open failed!\n"</span>); </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用完文件以后，要记得使用close来关闭文件。一旦调用close，则该进程对文件所加的锁全都被释放，并且使文件的打开引用计数减1，只有文件的打开引用计数变为0以后，文件才会被真正的关闭。用ulimit -a命令可以查看单个进程能同时打开的文件的上限。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; <span class="comment">//fd表示文件描述符,是先前由open或creat创建文件时的返回值。</span></span><br></pre></td></tr></table></figure>

<h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><ul>
<li>使用read和write来读写文件，它们统称为不带缓冲的IO</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;<span class="comment">//文件描述符 缓冲区 长度 s</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于read和write函数，出错返回-1，读取完了之后，返回0，其他情况返回读写的个数。</li>
</ul>
<h2 id="改变文件的大小"><a href="#改变文件的大小" class="headerlink" title="改变文件的大小"></a>改变文件的大小</h2><ul>
<li>使用ftruncate函数可以文件大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用mmap函数经常配合函数ftruncate来扩大文件大小。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例 #include &lt;func.h&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123; ARGS_CHECK(argc,<span class="number">2</span>); <span class="keyword">int</span> fd = <span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR); ERROR_CHECK(fd,<span class="number">-1</span>,<span class="string">"open"</span>); <span class="built_in">printf</span>(<span class="string">"fd = %d\n"</span>,fd); ftruncate(fd,<span class="number">5</span>) <span class="keyword">char</span> *p; p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,<span class="number">5</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); ERROR_CHECK(p,(<span class="keyword">char</span> *)<span class="number">-1</span>,<span class="string">"mmap"</span>); p[<span class="number">5</span>] = <span class="number">0</span>; <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p); p[<span class="number">0</span>] = <span class="string">'H'</span>; munmap(p,<span class="number">5</span>); <span class="built_in">close</span>(fd);</span><br></pre></td></tr></table></figure>

<h2 id="文件描述符的复制"><a href="#文件描述符的复制" class="headerlink" title="文件描述符的复制"></a>文件描述符的复制</h2><ul>
<li>系统调用函数dup和dup2可以实现文件描述符的复制</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>dup返回一个新的文件描述符（是自动分配的，数值是没有使用的文件描述符的最小编号）。这个新的描述符是旧文件描述符的拷贝。这意味着两个描述符共享同一个数据结构。</p>
</li>
<li><p>dup2允许调用者用一个有效描述符(oldfd)和目标描述符(newfd)。函数成功返回时，目标描述符将变成旧描述符的复制品，此时两个文件描述符现在都指向oldfd指向的文件（执行完成以后，如果newfd已经打开了文件，该文件将会被关闭）。</p>
</li>
</ul>
<h1 id="I-O多路复用与select"><a href="#I-O多路复用与select" class="headerlink" title="I/O多路复用与select"></a>I/O多路复用与select</h1><ul>
<li>I/O多路转接模型：在这种模型下，如果请求的I/O操作阻塞，且它不是真正阻塞I/O，而是让其中的一个函数等待，在这期间，I/O还能进行其他操作。</li>
</ul>
<p>系统调用select：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span> maxfd,</span></span></span><br><span class="line"><span class="function"><span class="params">			fd_set *readset, </span></span></span><br><span class="line"><span class="function"><span class="params">			fd_set *writeset, </span></span></span><br><span class="line"><span class="function"><span class="params">			fd_set *exceptionset, </span></span></span><br><span class="line"><span class="function"><span class="params">			struct timeval * timeout</span></span></span><br><span class="line"><span class="function"><span class="params">			)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	maxfd：最大的文件描述符（其值应该为最大的文件描述符字 + 1） </span></span><br><span class="line"><span class="comment">	readset：内核读操作的描述符字集合 (传入传出参数)</span></span><br><span class="line"><span class="comment">	writeset：内核写操作的描述符字集合 </span></span><br><span class="line"><span class="comment">	exceptionset：内核异常操作的描述符字集合 </span></span><br><span class="line"><span class="comment">	timeout：等待描述符就绪需要多少时间。NULL=永远等下去，固定值=等待固定时间，0=不等待，检查描述字之后立即返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值: 为就绪描述字的正数目，0——超时，-1——出错</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	maxfd为什么是最大描述符加1呢？</span></span><br><span class="line"><span class="comment">	当传入fdmax的时候，select会监听0~fdmax-1的文件描述符</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fdset实际上是一个文件描述符的位图，采用数组的形式来存储。下面是一个简化版本的实现方法:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fd_set的成员是一个长整型的结构体 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> __fd_mask; </span><br><span class="line"><span class="comment">//将字节转化为位 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NFDBITS (8 * (int) sizeof (__fd_mask))</span></span><br><span class="line"><span class="comment">//位图-判断是否存在文件描述符d </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_MASK(d) ((__fd_mask) (1UL &lt;&lt; ((d) % __NFDBITS))) </span></span><br><span class="line"><span class="comment">//select和pselect的fd_set结构体 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line"><span class="comment">//成员就是一个长整型的数组，用来实现位图 </span></span><br><span class="line">__fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS]; </span><br><span class="line">&#125; fd_set; </span><br><span class="line"><span class="comment">// fd_set里面文件描述符的数量，可以使用ulimit -n进行查看 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE __FD_SE	TSIZE</span></span><br></pre></td></tr></table></figure>

<p>有关文件描述符集合的操作通过以下四个宏来完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;         <span class="comment">//将fdset所指向的集合初始化为空 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">//将文件描述符fd添加到fdset所指向的集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">//将文件描述符fd从fdset所指向的集合中移除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//判断一个fd是否是fdset所指向集合中的成员</span></span><br></pre></td></tr></table></figure>

<p>若只监控读操作：<br>readset 是传入传出参数，它的作用是：<br>select()操作执行前，先通过FD_SET()将要监控的文件描述符添加到一个集合中，select()执行时，这个集合由readset传入内核，然后将rdset所指向的集合清空，select执行完毕，将该集合中所有可读的描述符再组成一个集合，写入到readset中。<br>然后通过FD_ISSET()就可判断所给的fd是否在新的readset中，及是否可读。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(1) - 常用命令</title>
    <url>/2020/01/26/Linux%5B1%5D%20-%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h1><p>新建(添加)用户<br><code>$ useradd [username]</code><br><code>$ useradd -m [username] -s /bin/bash  #添加用户并指定家目录</code> <a id="more"></a><br>配置密码<br><code>$ sudo passwd [username]</code><br>切换用户<br><code>$ su [username]</code><br>显示所有用户<br><code>cat /etc/passwd</code><br>退出当前用户<br><code>$ exit</code><br>删除用户<br><code>$ userdel [username]</code><br><code>$ userdel -r [username] #删除用户及家目录下的文件</code></p>
<h2 id="给某一普通用户配置sudo权限"><a href="#给某一普通用户配置sudo权限" class="headerlink" title="给某一普通用户配置sudo权限"></a>给某一普通用户配置sudo权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.切换到root用户：</span><br><span class="line">$ su root </span><br><span class="line"></span><br><span class="line">#2.添加sudoers文件写权限：</span><br><span class="line">$ chmod u+w &#x2F;etc&#x2F;sudoers </span><br><span class="line"></span><br><span class="line">#3.编辑sudoers文件</span><br><span class="line">vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">#找到 root ALL&#x3D;(ALL) ALL，在他其下面添加：</span><br><span class="line">xxx ALL&#x3D;(ALL) ALL (xxx &#x3D; 用户名)</span><br><span class="line"></span><br><span class="line">#可选一下任意一种形式：</span><br><span class="line">#允许用户youuser执行sudo命令(需要输入密码):</span><br><span class="line">username            ALL&#x3D;(ALL)                ALL</span><br><span class="line">#允许用户组youuser里面的用户执行sudo命令(需要输入密码)：</span><br><span class="line">%username           ALL&#x3D;(ALL)                ALL</span><br><span class="line">#允许用户youuser执行sudo命令,并且在执行的时候不输入密码：</span><br><span class="line">username            ALL&#x3D;(ALL)                NOPASSWD: ALL</span><br><span class="line">#允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码：</span><br><span class="line">%username           ALL&#x3D;(ALL)                NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line">#4.撤销sudoers文件写权限：</span><br><span class="line">$ chmod u-w &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure>
<p>如此，普通用户就可以使用sudo了。<br>（来源：<a href="https://www.jianshu.com/p/3d435e09712a）" target="_blank" rel="noopener">https://www.jianshu.com/p/3d435e09712a）</a></p>
<h1 id="文件目录相关"><a href="#文件目录相关" class="headerlink" title="文件目录相关"></a>文件目录相关</h1><h2 id="显示与查看"><a href="#显示与查看" class="headerlink" title="显示与查看"></a>显示与查看</h2><p>显示当前工作目录<br><code>$ pwd</code><br>查看当前工作目录下所有文件<br><code>$ ls</code><br><code>$ ls -a    #同时显示隐藏文件</code><br><code>$ ls -l    #显示详细信息</code><br><code>$ ls -la   #显示详细信息（包括隐藏文件） 别名：ll</code><br><code>$ ls -lh   #将文件大小按照合适的单位显示</code><br>树状目录结构显示<br><code>$ sudo apt install tree    #首次使用需要安装tree</code><br><code>$ tree [pathname]    #显示目录树状结构</code></p>
<h2 id="转移当前目录"><a href="#转移当前目录" class="headerlink" title="转移当前目录"></a>转移当前目录</h2><p>改变当前工作目录 (前往某一目录)<br><code>$ cd [pathname]</code><br>回到上次目录<br><code>$ cd -</code><br>转移到家目录<br><code>$cd ~</code><br>转移到根目录<br><code>$ cd /</code><br>转移到上级目录<br><code>$ cd ..</code></p>
<h2 id="目录创建与删除"><a href="#目录创建与删除" class="headerlink" title="目录创建与删除"></a>目录创建与删除</h2><p>创建目录<br><code>$ mkdir [cataname]</code><br>删除目录<br><code>$ rmdir [cataname]    #不能删除非空目录</code><br><code>$ rm -rf [cataname]    #删除目录及其下一切文件</code></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>删除文件<br><code>$ rm [mode] [username]|[pathname]</code><br>移动文件<br><code>$ mv [mode] [源文件] [目标路径]|[目标文件]</code><br>拷贝文件<br><code>$ cp [mode] [源文件] [目标路径]|[目标文件]</code></p>
<h1 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h1><h2 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h2><p>通过ls -l 命令可查看当前目录下文件权限</p>
<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p><code>$ chmod [who][+|-|=][mode] [filename]</code></p>
<ul>
<li>who代表用户类型：u表示用户，g表示组成员，o表示其他用户，a或者不写代表所有用户（ugo三个字母可以组合） </li>
<li>+|-|=代表操作符：+表示添加某个权限，-表示取消某个权限，=表示设置成某种权限 </li>
<li>mode代表模式，使用rwx三个字母的组合，r表示可读，w表示可写，x表示可执行</li>
</ul>
<p><code>$ chmod 666 [filename]    #可以用数字表示三类用户的权限</code></p>
<h2 id="修改文件所有者、所在组"><a href="#修改文件所有者、所在组" class="headerlink" title="修改文件所有者、所在组"></a>修改文件所有者、所在组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改文件所有者：</span><br><span class="line">chgrp [username] [filename] -R</span><br><span class="line">#修改文件所在组：</span><br><span class="line">chown [username] [filename]  -R</span><br><span class="line"></span><br><span class="line"># -R表示递归目录下所有文件</span><br></pre></td></tr></table></figure>

<h1 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h1><p>使用find命令来查找文件<br><code>$ find [起始目录] [查找条件] [操作]</code></p>
<h2 id="查找条件"><a href="#查找条件" class="headerlink" title="查找条件"></a>查找条件</h2><p><code>-name</code>            查找文件名匹配所给<strong>字符串</strong>的所有文件，字串内可用通配符*、?、[、]<br><code>-gid</code>             查找属于ID号为n的用户组的所有文件<br><code>-uid</code>             查找属于ID号为n的用户的所有文件<br><code>-group &#39;string&#39;</code>  查找属于用户组名为所给字串的所有的文件<br><code>-user &#39;string&#39;</code>   查找属于用户名为所给字串的所有的文件<br><code>-empty</code>           查找大小为0的目录或文件<br><code>-size n[bckw]</code>    n后面的字符表示单位，缺省为b，代表512字节的块<br><code>-type x</code>          查找类型为x的文件</p>
<h2 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h2><h3 id="用来匹配任意个字符"><a href="#用来匹配任意个字符" class="headerlink" title="* 用来匹配任意个字符"></a>* 用来匹配任意个字符</h3><p>若当前目录里面有文件file，file1，file123，file2，file3，file4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -name &quot;file*&quot;</span><br><span class="line">#结果是</span><br><span class="line">.&#x2F;file1 </span><br><span class="line">.&#x2F;file </span><br><span class="line">.&#x2F;file123</span><br><span class="line">.&#x2F;file2 </span><br><span class="line">.&#x2F;file3 </span><br><span class="line">.&#x2F;file4</span><br></pre></td></tr></table></figure>
<h3 id="用来匹配1个任意字符"><a href="#用来匹配1个任意字符" class="headerlink" title="? 用来匹配1个任意字符"></a>? 用来匹配1个任意字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -name &quot;file?&quot;</span><br><span class="line">#结果是</span><br><span class="line">.&#x2F;file1</span><br><span class="line">.&#x2F;file2</span><br><span class="line">.&#x2F;file3 </span><br><span class="line">.&#x2F;file4</span><br></pre></td></tr></table></figure>
<h3 id="用来匹配某个范围内的字符"><a href="#用来匹配某个范围内的字符" class="headerlink" title="[] 用来匹配某个范围内的字符"></a>[] 用来匹配某个范围内的字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -name &quot;file[0-9]&quot;</span><br><span class="line">#结果是</span><br><span class="line">.&#x2F;file1 </span><br><span class="line">.&#x2F;file2 </span><br><span class="line">.&#x2F;file3 </span><br><span class="line">.&#x2F;file4</span><br></pre></td></tr></table></figure>
<h2 id="根据时间查找"><a href="#根据时间查找" class="headerlink" title="根据时间查找"></a>根据时间查找</h2><p><code>amin n</code> 查找n分钟以前被访问过的所有文件（+表示n分钟之前，-表示n分钟之内，+号和-号都不能省略）<br><code>cmin n</code> 查找n分钟以前文件状态被修改过的所有文件<br><code>mmin n</code> 查找n分钟以前文件内容被修改过的所有文件<br><code>atime n</code> 查找n天以前被访问过的所有文件<br><code>ctime n</code> 查找n天以前文件状态被修改过的所有文件<br><code>mtime n</code> 查找n天以前文件内容被修改过的所有文件</p>
<h1 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h1><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><h3 id="程序执行完后使用echo"><a href="#程序执行完后使用echo" class="headerlink" title="程序执行完后使用echo"></a>程序执行完后使用echo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $0 :shell或shell脚本的名字</span><br><span class="line"></span><br><span class="line">echo $* :以一对双引号给出参数列表</span><br><span class="line"></span><br><span class="line">echo $@ :将各个参数分别加双引号返回</span><br><span class="line"></span><br><span class="line">echo $# :参数的个数</span><br><span class="line"></span><br><span class="line">echo $_ : 代表上一个命令的最后一个参数</span><br><span class="line"></span><br><span class="line">echo $$ :代表所在命令的PID</span><br><span class="line"></span><br><span class="line">echo $! :代表最后执行的后台命令的PID</span><br></pre></td></tr></table></figure>

<h1 id="将一些命令封装在一个文件里方便快捷执行"><a href="#将一些命令封装在一个文件里方便快捷执行" class="headerlink" title="将一些命令封装在一个文件里方便快捷执行"></a>将一些命令封装在一个文件里方便快捷执行</h1><p>比如，我想自己定义一个qmake命令来完成以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~&#x2F;makefile .   #将家目录里写好的Makefile文件拷贝到当前目录</span><br><span class="line">make              #执行make命令</span><br></pre></td></tr></table></figure>
<p>则需要先<code>vim qmake</code> ，将上述代码写进去，<br>然后将qmake文件拷贝到/usr/bin目录下（需使用sudo权限）:<br><code>sudo cp qmake /usr/bin</code><br>当然，需要保证/usr/bin文件夹下没有名为qmake的文件。<br>以后只需要在当前目录下直接输入qmake即可执行定义好的上面两个操作了:)。</p>
<h1 id="sudo-出现unable-to-resolve-host-解决方法"><a href="#sudo-出现unable-to-resolve-host-解决方法" class="headerlink" title="sudo 出现unable to resolve host 解决方法"></a>sudo 出现unable to resolve host 解决方法</h1><p>虽然sudo 还是可以正常执行, 所以就直接从/etc/hosts 设定, 让abc(hostname) 可以解回127.0.0.1 的IP 即可.<br>在127.0.0.1 localhost 后面加上主机名称(hostname) 即可:<br>127.0.0.1       localhost cloud</p>
<h1 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1、方法一使用hostnamectl命令</span><br><span class="line"># hostnamectl set-hostname [hostname]</span><br><span class="line"> </span><br><span class="line">#方法二：修改配置文件 &#x2F;etc&#x2F;hostname </span><br><span class="line"># vim &#x2F;etc&#x2F;hostname</span><br><span class="line">保存退出</span><br></pre></td></tr></table></figure>

<h1 id="ubuntu环境下安装vimplus插件"><a href="#ubuntu环境下安装vimplus插件" class="headerlink" title="ubuntu环境下安装vimplus插件"></a>ubuntu环境下安装vimplus插件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  sudo apt install git </span><br><span class="line"></span><br><span class="line">2  git clone https:&#x2F;&#x2F;gitee.com&#x2F;cskaoyan123&#x2F;vimplus.git ~&#x2F;.vimplus</span><br><span class="line"></span><br><span class="line">3  .cd ~&#x2F;.vimplus</span><br><span class="line"></span><br><span class="line">4  .&#x2F;install.sh</span><br><span class="line"></span><br><span class="line">5  vim-addon-manager remove youcompleteme</span><br><span class="line"></span><br><span class="line">相关帮助文档</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;75cde8a80fd7</span><br><span class="line"></span><br><span class="line">预生成代码在路径</span><br><span class="line">~&#x2F;.vim&#x2F;plugged&#x2F;prepare-code下</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/01/25/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="markdown编辑器"><a href="#markdown编辑器" class="headerlink" title="markdown编辑器"></a>markdown编辑器</h1><p>比较Typora, 目前使用sublime。</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1>]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
