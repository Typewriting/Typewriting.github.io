<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux(22) - 网络编程</title>
    <url>/2020/02/03/Linux%2022%20-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><h3 id="socket类型"><a href="#socket类型" class="headerlink" title="socket类型"></a>socket类型</h3><p>1)流式socket(SOCK_STREAM) -&gt;用于TCP 通信</p>
<p>2)数据报socket(SOCK_DGRAM) -&gt;用于UDP 通信<a id="more"></a></p>
<p>3)原始socket(SOCK_RAW) -&gt;用于用于新的网络协议实现的测试等</p>
<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/*14 字节的协议地址，包含该socket 的IP 地址和端口号。*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实际编程中使用下面这个更方便的接口：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">	short <span class="keyword">int</span> sin_family; <span class="comment">/*地址族*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> short <span class="keyword">int</span> sin_port; <span class="comment">/*端口号*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*IP 地址*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/*填充0 以保持与struct sockaddr 同样大小*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sin_family:</span></span><br><span class="line"><span class="comment"> AF_INET  = IPv4 协议</span></span><br><span class="line"><span class="comment"> AF_INET6 = IPv6 协议</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">	<span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="数据存储优先顺序（大小端）的转换"><a href="#数据存储优先顺序（大小端）的转换" class="headerlink" title="数据存储优先顺序（大小端）的转换"></a>数据存储优先顺序（大小端）的转换</h2><ul>
<li><p>主机字节序：小端模式(Intel)</p>
</li>
<li><p>网络字节序：大端模式</p>
<p>在网络上进行通信，则数据必须转化为网络字节序</p>
<p>实现网络字节序和主机字节序的转，用到的函数有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> htons();</span><br><span class="line"> <span class="comment">//将无符号短整型数转换为网络字节序</span></span><br><span class="line"> ntohs();</span><br><span class="line"> <span class="comment">//将无符号短整型数转换为主机字节序</span></span><br><span class="line"> htonl();</span><br><span class="line"> <span class="comment">//将无符号长整形数转换位网络字节序</span></span><br><span class="line"> ntohl();</span><br><span class="line"> <span class="comment">//将无符号短整型数转换为主机字节序</span></span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">	h = host</span><br><span class="line">	n = network</span><br><span class="line">	s = short</span><br><span class="line">	l = <span class="keyword">long</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="地址格式转化"><a href="#地址格式转化" class="headerlink" title="地址格式转化"></a>地址格式转化</h2><p>+点分十进制和32位网络字节序相互转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//点分十进制IP地址转换为32位网络字节序</span></span><br><span class="line"><span class="comment">//ipv4:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *straddr, struct in_addr *addrptr)</span></span>;	</span><br><span class="line"><span class="comment">//成功返回1，不成功返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *straddr)</span>	</span></span><br><span class="line"><span class="function"><span class="comment">//成功返回32位网络字节序地址 </span></span></span><br><span class="line"><span class="function"><span class="comment">//straddr：存放输入的点分十进制数IP 地址字符串。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//ipv4/6:</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">//family: AF_INET = IPv4协议 ; AF_INET6 = IPv6 协议。</span></span><br><span class="line"><span class="comment">//点分十进制IP地址转换为32位网络字节序:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4:</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4/6:</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="名字地址转化"><a href="#名字地址转化" class="headerlink" title="名字地址转化"></a>名字地址转化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *h_name; 		<span class="comment">/*正式主机名*/</span></span><br><span class="line"><span class="keyword">char</span> **h_aliases;   <span class="comment">/*主机别名*/</span></span><br><span class="line"><span class="keyword">int</span> h_addrtype;     <span class="comment">/*主机IP地址类型IPv4 为AF_INET*/</span></span><br><span class="line"><span class="keyword">int</span> h_length;       <span class="comment">/*主机IP地址字节长度，IPv4  = 4 字节*/</span></span><br><span class="line"><span class="keyword">char</span> **h_addr_list; <span class="comment">/*主机的IP地址列表*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主机名（或域名）转化为IP地址：</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IP地址转化为主机名：</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PS：需要联网</span></span><br></pre></td></tr></table></figure>

<h1 id="socket-编程"><a href="#socket-编程" class="headerlink" title="socket 编程"></a>socket 编程</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 通信的基本步骤如下：</p>
<p>server：<br>socket–bind–listen–while(1){accept—recv—send–close}–close</p>
<p>client：<br>socket————————-connect–send—recv——- –close</p>
<ul>
<li>用到的头文件：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h4><ul>
<li>作用：<br>生成一个套接口描述符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">domain: AF_INET = Ipv4</span></span><br><span class="line"><span class="comment">	      AF_INET6 = IPv6</span></span><br><span class="line"><span class="comment">type:   SOCK_STREAM = TCP</span></span><br><span class="line"><span class="comment">		SOCK_DGRAM  = UDP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回值：成功返回套接口描述符，失败返回-1。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> socketFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">ERROR_CHECK(socketFd, <span class="string">"socket"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><ul>
<li>作用：<br>用来绑定一个端口号和IP 地址，使套接口与指定的端口号和IP 地址相关联。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * my_addr,<span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd:前面socket 的返回值。</span></span><br><span class="line"><span class="comment">	my_addr:结构体指针变量</span></span><br><span class="line"><span class="comment">	addrlen:sockaddr的结构体长度。通常是计算sizeof(struct sockaddr);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	对于不同的socket domain 定义了一个通用的数据结构struct sockaddr</span></span><br><span class="line"><span class="comment">	此结构会因使用不同的socket domain 而有不同结构定义，</span></span><br><span class="line"><span class="comment">	例如使用AF_INET domain，其socketaddr 结构定义便为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> //此结构体不常用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short <span class="keyword">int</span> sa_family; <span class="comment">//调用socket()时的domain参数，即AF_INET值。</span></span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">//最多使用14个字符长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> //常用的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short <span class="keyword">int</span> sin_family; <span class="comment">//sa_family (AF_INET)</span></span><br><span class="line">	<span class="keyword">uint16_t</span> sin_port; <span class="comment">//使用的port 编号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//IP地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">//未使用</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span> <span class="comment">//定义结构体变量</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr)); <span class="comment">//将结构体清空</span></span><br><span class="line">	<span class="comment">//或bzero(&amp;my_addr, sizeof(struct sockaddr));</span></span><br><span class="line">my_addr.sin_family = AF_INET; <span class="comment">//采用Ipv4</span></span><br><span class="line">my_addr.sin_port = htons(<span class="number">2000</span>); <span class="comment">//端口号设为2000，通常大于1024</span></span><br><span class="line">	<span class="comment">//htons()用来将参数指定的16 位hostshort 转换成网络字符顺序</span></span><br><span class="line">my_addr.sin_addr.s_addr = inet_addr(<span class="string">"192.168.0.101"</span>); </span><br><span class="line">	<span class="comment">//inet_addr()用来将IP 地址字符串转换成网络所使用的二进制数字，如果为INADDR_ANY，这表示服务器自动填充本机IP。 </span></span><br><span class="line">bind(sfd, (struct sockaddr*)&amp;my_str, <span class="keyword">sizeof</span>(struct socketaddr);</span><br><span class="line">ERROR_CHECK(bind, <span class="number">-1</span>, <span class="string">"bind"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	通过将my_addr.sin_port 置为0，函数会自动为你选择一个未占用的端口来使用。</span></span><br><span class="line"><span class="comment">	同样，通过将my_addr.sin_addr.s_addr 置为INADDR_ANY，系统会自动填入本机IP 地址</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><ul>
<li>作用：<br>使服务器的这个端口和IP 处于监听状态，等待网络中某一客户机的连接请求。如果客户<br>端有连接请求，端口就会接受这个连接。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd: 前面socket的返回值</span></span><br><span class="line"><span class="comment">	backlog：指定同时能处理的最大连接要求，通常为10 或者5。最大值可设至128</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：成功则返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = <span class="built_in">listen</span>(sfd, <span class="number">10</span>);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"listen"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><ul>
<li>作用：</li>
</ul>
<ol>
<li><p>接受远程计算机的连接请求，建立起与客户机之间的通信连接。</p>
</li>
<li><p>服务器处于监听状态时，如果某时刻获得客户机的连接请求，此时并不是立即处理这个请求，而是将这个请求放在等待队列中，<br>当系统空闲时再处理客户机的连接请求。</p>
</li>
<li><p>当accept 函数接受一个连接时，会返回一个新的socket 标识符，<br>以后的数据传输和读取就要通过这个新的socket 编号来处理，原来参数中的socket 也可以继续使用，继续监听其它客户机的连接请求。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> s, struct sockaddr * addr, <span class="keyword">int</span> * addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	s: 前面socket的返回值</span></span><br><span class="line"><span class="comment">	addr: 结构体指针变量，系统会把远程主机的信息（远程主机的地址和端口号信息）保存到这个指针所指的结构体中。</span></span><br><span class="line"><span class="comment">	addrlen: 表示结构体的长度，为整型指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：成功则返回新的socket 处理代码new_fd，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;clientaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line"><span class="keyword">int</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"><span class="keyword">int</span> new_fd = accept(sfd, (struct sockaddr*)&amp;clientaddr, &amp;addrlen);</span><br><span class="line">ERROR_CHECK(new_fd, <span class="number">-1</span>, <span class="string">"accept"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %d success connect\n"</span>,inet_ntoa(clientaddr.sin_addr),ntohs(clientaddr.sin_port));</span><br></pre></td></tr></table></figure>

<h4 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h4><ul>
<li>作用：<br>用新的套接字来接收远端主机传来的数据，并把数据存到由参数buf 指向的内存空间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd: 前面accept 的返回值.即new_fd</span></span><br><span class="line"><span class="comment">	buf: 缓冲区</span></span><br><span class="line"><span class="comment">	len: 表示缓冲区的长度</span></span><br><span class="line"><span class="comment">	flags:通常为0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值: 成功返回实际接收到的字符数，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">ret = recv(new_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"recv"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><ul>
<li>作用：<br>用新的套接字发送数据给指定的远端主机</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">const</span> <span class="keyword">void</span> * msg,<span class="keyword">int</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	s:前面accept 的返回值.即new_fd</span></span><br><span class="line"><span class="comment">	msg: 常量字符串</span></span><br><span class="line"><span class="comment">	len: 长度</span></span><br><span class="line"><span class="comment">	flags: 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值: 成功返回实际传送出去的字符数，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = send(new_fd, <span class="string">"hello"</span>, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">"send"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>+作用：<br>：当使用完文件后若已不再需要则可使用close()关闭该文件，并且close()会让数据写回磁盘，并释放该文件所占用的资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	fd：为前面的sfd,new_fd</span></span><br><span class="line"><span class="comment">	返回值：若文件顺利关闭返回0，发生错误返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(new_fd);</span><br><span class="line"><span class="built_in">close</span>(sfd);</span><br></pre></td></tr></table></figure>

<p>可以调用shutdown 实现半关闭：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><ul>
<li>作用：<br>用来请求连接远程服务器，将参数sockfd的socket连至参数serv_addr 指定的服务器IP和端口号上去。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * serv_addr, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sockfd：为前面的socketsocket的返回值，即sfd</span></span><br><span class="line"><span class="comment">	serv_addr: 为结构体指针变量，存储着远程服务器的IP 与端口号信息。</span></span><br><span class="line"><span class="comment">	addrlen: 表示结构体变量的长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值: 成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span><span class="comment">//请求连接服务器</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">seraddr.sin_family = AF_INET;</span><br><span class="line">seraddr.sin_port = htons(<span class="number">2000</span>); <span class="comment">//服务器的端口号</span></span><br><span class="line">seraddr.sin_addr.s_addr = inet_addr(<span class="string">"192.168.0.101"</span>); <span class="comment">//服务器的ip</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">connect</span>(sfd, (struct sockaddr*)&amp;seraddr, <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"connect"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="socket，send-recv-close-同server"><a href="#socket，send-recv-close-同server" class="headerlink" title="socket，send, recv, close 同server"></a>socket，send, recv, close 同server</h4><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><p>tcp_server.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="comment">//初始化一个socket，有一个缓冲区</span></span><br><span class="line">    socketFd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);                                       </span><br><span class="line">    ERROR_CHECK(socketFd,<span class="number">-1</span>,<span class="string">"socket"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socketFd=%d\n"</span>,socketFd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser</span>;</span></span><br><span class="line">    bzero(&amp;ser,<span class="keyword">sizeof</span>(ser));</span><br><span class="line">    ser.sin_family=AF_INET;</span><br><span class="line">    ser.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    ser.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret=bind(socketFd,(struct sockaddr *)&amp;ser,<span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"bind"</span>);</span><br><span class="line">    <span class="built_in">listen</span>(socketFd,<span class="number">10</span>);<span class="comment">//端口激活</span></span><br><span class="line">    <span class="keyword">int</span> new_fd;<span class="comment">//用来保存新建连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span><span class="comment">//从内核拿出对方的socket信息</span></span><br><span class="line">    bzero(&amp;client,<span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(client);</span><br><span class="line">    new_fd=accept(socketFd,(struct sockaddr *)&amp;client,&amp;len);</span><br><span class="line">    ERROR_CHECK(new_fd,<span class="number">-1</span>,<span class="string">"accept"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip=%s,client port=%d\n"</span>,inet_ntoa(client.sin_addr),ntohs(client</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">int</span> readyFdNum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO,&amp;rdset);</span><br><span class="line">        FD_SET(new_fd,&amp;rdset);</span><br><span class="line">        readyFdNum=select(new_fd+<span class="number">1</span>,&amp;rdset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(readyFdNum&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(new_fd,&amp;rdset))</span><br><span class="line">            &#123;</span><br><span class="line">                bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret=recv(new_fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(!ret)<span class="comment">//对方断开了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"byebye\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO,&amp;rdset))</span><br><span class="line">            &#123;</span><br><span class="line">                bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                send(new_fd,buf,<span class="built_in">strlen</span>(buf)<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line">    <span class="built_in">close</span>(socketFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcp_server.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> socketFd;</span><br><span class="line">    <span class="comment">//初始化一个socket，有一个缓冲区</span></span><br><span class="line">    socketFd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socketFd,<span class="number">-1</span>,<span class="string">"socket"</span>);                                            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"socketFd=%d\n"</span>,socketFd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser</span>;</span></span><br><span class="line">    bzero(&amp;ser,<span class="keyword">sizeof</span>(ser));</span><br><span class="line">    ser.sin_family=AF_INET;</span><br><span class="line">    ser.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    ser.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret=bind(socketFd,(struct sockaddr *)&amp;ser,<span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">    ERROR_CHECK(ret,<span class="number">-1</span>,<span class="string">"bind"</span>);</span><br><span class="line">    <span class="built_in">listen</span>(socketFd,<span class="number">10</span>);<span class="comment">//端口激活</span></span><br><span class="line">    <span class="keyword">int</span> new_fd;<span class="comment">//用来保存新建连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span><span class="comment">//从内核拿出对方的socket信息</span></span><br><span class="line">    bzero(&amp;client,<span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">socklen_t</span> len=<span class="keyword">sizeof</span>(client);</span><br><span class="line">    new_fd=accept(socketFd,(struct sockaddr *)&amp;client,&amp;len);</span><br><span class="line">    ERROR_CHECK(new_fd,<span class="number">-1</span>,<span class="string">"accept"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip=%s,client port=%d\n"</span>,inet_ntoa(client.sin_addr),ntohs(client</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">int</span> readyFdNum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO,&amp;rdset);</span><br><span class="line">        FD_SET(new_fd,&amp;rdset);</span><br><span class="line">        readyFdNum=select(new_fd+<span class="number">1</span>,&amp;rdset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(readyFdNum&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(new_fd,&amp;rdset))</span><br><span class="line">            &#123;</span><br><span class="line">                bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret=recv(new_fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(!ret)<span class="comment">//对方断开了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"byebye\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO,&amp;rdset))</span><br><span class="line">            &#123;</span><br><span class="line">                bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                send(new_fd,buf,<span class="built_in">strlen</span>(buf)<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line">    <span class="built_in">close</span>(socketFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 通信流程图如下：</p>
<p>server：<br>socket–bind–recvfrom—sendto–close<br>client：<br>socket——–sendto—recvfrom–close </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(22) - 网络编程</title>
    <url>/2020/02/03/Linux%20%5B22%5D%20-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><h3 id="socket类型"><a href="#socket类型" class="headerlink" title="socket类型"></a>socket类型</h3><p>1)流式socket(SOCK_STREAM) -&gt;用于TCP 通信</p>
<p>2)数据报socket(SOCK_DGRAM) -&gt;用于UDP 通信<a id="more"></a></p>
<p>3)原始socket(SOCK_RAW) -&gt;用于用于新的网络协议实现的测试等</p>
<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/*14 字节的协议地址，包含该socket 的IP 地址和端口号。*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实际编程中使用下面这个更方便的接口：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">	short <span class="keyword">int</span> sin_family; <span class="comment">/*地址族*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> short <span class="keyword">int</span> sin_port; <span class="comment">/*端口号*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*IP 地址*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/*填充0 以保持与struct sockaddr 同样大小*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sin_family:</span></span><br><span class="line"><span class="comment"> AF_INET  = IPv4 协议</span></span><br><span class="line"><span class="comment"> AF_INET6 = IPv6 协议</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">	<span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="数据存储优先顺序（大小端）的转换"><a href="#数据存储优先顺序（大小端）的转换" class="headerlink" title="数据存储优先顺序（大小端）的转换"></a>数据存储优先顺序（大小端）的转换</h2><p> 主机字节序：小端模式(Intel)</p>
<p> 网络字节序：大端模式</p>
<p> 在网络上进行通信，则数据必须转化为网络字节序</p>
<p> 实现网络字节序和主机字节序的转，用到的函数有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> htons();</span><br><span class="line"> <span class="comment">//将无符号短整型数转换为网络字节序</span></span><br><span class="line"> ntohs();</span><br><span class="line"> <span class="comment">//将无符号短整型数转换为主机字节序</span></span><br><span class="line"> htonl();</span><br><span class="line"> <span class="comment">//将无符号长整形数转换位网络字节序</span></span><br><span class="line"> ntohl();</span><br><span class="line"> <span class="comment">//将无符号短整型数转换为主机字节序</span></span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">	h = host</span><br><span class="line">	n = network</span><br><span class="line">	s = short</span><br><span class="line">	l = <span class="keyword">long</span></span><br></pre></td></tr></table></figure>

<h2 id="地址格式转化"><a href="#地址格式转化" class="headerlink" title="地址格式转化"></a>地址格式转化</h2><p>点分十进制和32位网络字节序相互转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//点分十进制IP地址转换为32位网络字节序</span></span><br><span class="line"><span class="comment">//ipv4:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *straddr, struct in_addr *addrptr)</span></span>;	</span><br><span class="line"><span class="comment">//成功返回1，不成功返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *straddr)</span>	</span></span><br><span class="line"><span class="function"><span class="comment">//成功返回32位网络字节序地址 </span></span></span><br><span class="line"><span class="function"><span class="comment">//straddr：存放输入的点分十进制数IP 地址字符串。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//ipv4/6:</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">//family: AF_INET = IPv4协议 ; AF_INET6 = IPv6 协议。</span></span><br><span class="line"><span class="comment">//点分十进制IP地址转换为32位网络字节序:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4:</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4/6:</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="名字地址转化"><a href="#名字地址转化" class="headerlink" title="名字地址转化"></a>名字地址转化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *h_name; 		<span class="comment">/*正式主机名*/</span></span><br><span class="line"><span class="keyword">char</span> **h_aliases;   <span class="comment">/*主机别名*/</span></span><br><span class="line"><span class="keyword">int</span> h_addrtype;     <span class="comment">/*主机IP地址类型IPv4 为AF_INET*/</span></span><br><span class="line"><span class="keyword">int</span> h_length;       <span class="comment">/*主机IP地址字节长度，IPv4  = 4 字节*/</span></span><br><span class="line"><span class="keyword">char</span> **h_addr_list; <span class="comment">/*主机的IP地址列表*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主机名（或域名）转化为IP地址：</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IP地址转化为主机名：</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> family)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PS：需要联网</span></span><br></pre></td></tr></table></figure>

<h1 id="socket-编程"><a href="#socket-编程" class="headerlink" title="socket 编程"></a>socket 编程</h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之环境变量PS1</title>
    <url>/2020/02/01/Linux%5B2%5D%20-%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FPS1/</url>
    <content><![CDATA[<h1 id="1-PS1是什么"><a href="#1-PS1是什么" class="headerlink" title="1.PS1是什么"></a>1.PS1是什么</h1><p>PS1是Linux终端用户的一个环境变量，用来定义命令行提示符的参数。<a id="more"></a><br>输入命令<br><code>$ echo $PS1</code><br>可得到当前定义的PS1值<br><code>\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$</code></p>
<h1 id="2-PS1参数"><a href="#2-PS1参数" class="headerlink" title="2.PS1参数"></a>2.PS1参数</h1><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　\d ：代表日期，格式为weekday month date，例如：&quot;Mon Aug 1&quot;</span><br><span class="line"></span><br><span class="line">　　\H ：完整的主机名称</span><br><span class="line"></span><br><span class="line">　　\h ：仅取主机名中的第一个名字</span><br><span class="line"></span><br><span class="line">　　\t ：显示时间为24小时格式，如：HH：MM：SS</span><br><span class="line"></span><br><span class="line">　　\T ：显示时间为12小时格式</span><br><span class="line"></span><br><span class="line">　　\A ：显示时间为24小时格式：HH：MM</span><br><span class="line"></span><br><span class="line">　　\u ：当前用户的账号名称</span><br><span class="line"></span><br><span class="line">　　\v ：BASH的版本信息</span><br><span class="line"></span><br><span class="line">　　\w ：完整的工作目录名称</span><br><span class="line"></span><br><span class="line">　　\W ：利用basename取得工作目录名称，只显示最后一个目录名</span><br><span class="line"></span><br><span class="line">　　\# ：下达的第几个命令</span><br><span class="line"></span><br><span class="line">　　\$ ：提示字符，如果是root用户，提示符为 # ，普通用户则为 $</span><br></pre></td></tr></table></figure>
<p>所以linux默认的命令行提示信息的格式<br><code>PS1=&#39;[\u@\h \W]\$ &#39;</code>  的意思就是：<br>[当前用户的账号名称@主机名的第一个名字 工作目录的最后一层目录名]#</p>
<p>##颜色设置参数<br>　在PS1中设置字符颜色的格式为：<code>\[\e[F;Bm\]........\[\e[0m\]</code><br>其中“F“为字体颜色，编号为30-37，“B”为背景颜色，编号为40-47,<code>\[\e[0m\]</code>作为颜色设定的结束。<br>　　颜色对照表：</p>
<p>　　　　F    B</p>
<p>　　　　30  40 黑色</p>
<p>　　　　31  41 红色</p>
<p>　　　　32  42 绿色</p>
<p>　　　　33  43 黄色</p>
<p>　　　　34  44 蓝色</p>
<p>　　　　35  45 紫红色</p>
<p>　　　　36  46 青蓝色</p>
<p>　　　　37  47 白色</p>
<p>修改颜色，只需将对应数字套入设置格式中即可。</p>
<p>比如要设置命令行的格式为绿字黑底([\e[32;40m])，显示当前用户的账号名称(\u)、主机的第一个名字(\h)、完整的当前工作目录名称(\w)、24小时格式时间(\t)，可以直接在命令行键入如下命令：<br><code>$ PS1=&#39;[\[\e[32;40m\]\u@\h \w \t]$ \[\e[0m\]&#39;</code><br>用以上方法修改PS1变量只是临时性的，下次登录即恢复原样。</p>
<h1 id="3-修改-bashrc文件-永久保存命令行样式"><a href="#3-修改-bashrc文件-永久保存命令行样式" class="headerlink" title="3.修改.bashrc文件,永久保存命令行样式"></a>3.修改.bashrc文件,永久保存命令行样式</h1><p>在家目录下使用ls -la命令即可看到.bashrc这个文件</p>
<p>编辑.bashrc文件，加入这一行：(以下是本人的设置)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PS1&#x3D;&quot;\[\e[31;1m\]\u@\[\e[34;1m\]\h \[\e[36;1m\]\w $\[\e[37;1m\] &quot;</span><br></pre></td></tr></table></figure>

<p>保存退出，然后重新加载bash配置文件:</p>
<p><code>$ source .bashrc</code></p>
<p>即可永久生效。<br>———<br>参考来源 <a href="https://www.cnblogs.com/Q--T/p/5394993.html" target="_blank" rel="noopener">https://www.cnblogs.com/Q--T/p/5394993.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(10) - time</title>
    <url>/2020/02/01/Linux%5B10%5D%20-%20time/</url>
    <content><![CDATA[<p>Linux中有如下几个显示时间的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *tloc)</span></span>;</span><br><span class="line"><span class="comment">//当前距离1970年1月1日00点00分00秒的秒数</span></span><br><span class="line"><span class="comment">//time_t = long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *timep)</span></span>;</span><br><span class="line"><span class="comment">//将秒数转换为字符串形式：星期 月 日 时间 年</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *timep)</span></span>;</span><br><span class="line"><span class="comment">//格林尼治时间</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(21) - 多线程</title>
    <url>/2020/01/29/Linux%5B21%5D%20-%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程是系统中程序执行和资源分配的基本单位。</p>
<p>线程是在共享内存空间中并发执行的多道执行路径，是进程的基本调度单元，一个进程内可拥有多个线程。（程序执行路径即函数栈的弹栈压栈过程）</p>
<p>它与同进程中的其他线程共享进程空间、<a id="more"></a>堆、代码、数据、文件描述符、信号等，只拥有自己的栈空间，大大减少了上下文切换的开销。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>线程和进程在使用上各有优缺点：</p>
<p>&emsp;线程执行开销小，占用的CPU少，线程之间的切换快，但不利于资源的管理和保护。</p>
<p>&emsp;进程正相反，从可移植性来讲，多进程的可移植性要好些。</p>
<h1 id="线程的Linux实现"><a href="#线程的Linux实现" class="headerlink" title="线程的Linux实现"></a>线程的Linux实现</h1><p>使用NPTL线程库实现，在编译时要在编译命令后面加-lpthread。</p>
<p>使用到的头文件为&lt;pthread.h&gt;，使用到的接口以pthread_开头。</p>
<p>因为pthread开头的接口，都不能用perror，故在头文件中新定义一个宏 THREAD_ERROR_CHECK 用来检查返回值是否正确：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_ERROR_CHECK(ret,funcName)\</span></span><br><span class="line"> &#123;<span class="keyword">if</span>(ret!=<span class="number">0</span>)\</span><br><span class="line"> &#123;<span class="built_in">printf</span>(<span class="string">"%s:%s\n"</span>,funcName,strerror(ret));<span class="keyword">return</span> <span class="number">-1</span>;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>线程创建采用函数pthread_create, 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, </span></span></span><br><span class="line"><span class="function"><span class="params">	           <span class="keyword">pthread_attr_t</span> * attr, </span></span></span><br><span class="line"><span class="function"><span class="params">	           <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="function"><span class="params">	           <span class="keyword">void</span> * arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>thread: 传出参数，保存新线程的标识（进程id）。</p>
<p>attr: 结构体指针，结构中的元素分别指定新线程的运行属性。通常NULL即可。</p>
<p>start_routine: 函数指针，指向新线程的入口点函数(本文命名为threadFunc)。</p>
<p>arg: 用于传递给start_routine指向的入口点函数（即threadFunc函数）的参数，可以为NULL，表示不传递。即向子进程传递参数时就要用的这个变量。</p>
<p>在64位操作系统中，指针变量占8个字节，若通过arg变量传一个整数，则大小也必须为8个字节（如long类型），int类型只占4字节所以不可用。</p>
<p>通常的形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthid;</span><br><span class="line">pthread_create(&amp;pthid,<span class="literal">NULL</span>,pthfunc,<span class="literal">NULL</span>);      <span class="meta">#arg为NULl时</span></span><br><span class="line">pthread_create(&amp;pthid,<span class="literal">NULL</span>,pthfunc,(<span class="keyword">void</span>*)<span class="number">3</span>);  #将<span class="number">3</span>传给threadFunc的参数p</span><br></pre></td></tr></table></figure>
<h2 id="线程函数-threadFunc"><a href="#线程函数-threadFunc" class="headerlink" title="线程函数 threadFunc"></a>线程函数 threadFunc</h2><p>内容为新线程的执行命令，由程序员自己编写，调用pthread_create创建新线程时，把其第3个参数start_routine填为threadFunc，则新线程的活动即为所写。</p>
<h2 id="线程的退出"><a href="#线程的退出" class="headerlink" title="线程的退出"></a>线程的退出</h2><p>线程退出有两种方式：</p>
<p>&emsp;1.线程从入口点函数自然返回(return 返回值，或执行完全部代码)；</p>
<p>&emsp;2.线程主动调用pthread_exit()函数。</p>
<h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">pthread_exit((<span class="keyword">void</span>*)<span class="number">3</span>);<span class="comment">//3作为返回值被pthread_join函数捕获。</span></span><br></pre></td></tr></table></figure>

<h2 id="线程的等待退出"><a href="#线程的等待退出" class="headerlink" title="线程的等待退出"></a>线程的等待退出</h2><p>若通过pthread_exit函数退出，则其参数可以被其它线程用pthread_join函数捕获。</p>
<h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> pthid, <span class="keyword">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure>
<p>1.该函数是一个阻塞函数，一直等到参数th指定的线程返回,；与多进程中的wait或waitpid类似。</p>
<p>2.<code>thread_return</code>是一个传出参数，接收线程函数的返回值。如果线程通过调用<code>pthread_exit()</code>终止，则<code>pthread_exit()</code>中的参数相当于自然返回值，照样可以被其它线程用<code>pthread_join</code>获取到。</p>
<p>3.该函数还有一个非常重要的作用，由于一个进程中的多个线程共享数据段，因此通常在一个线程退出后，退出线程所占用的资源并不会随线程结束而释放。如果pthid线程类型并不是自动清理资源类型的，则th线程退出后，线程本身的资源必须通过其它线程调用<code>pthread_join()</code>来清除,这相当于多进程程序中的waitpid。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pthread_example1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;func.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"I am child thread\n"</span>);</span><br><span class="line">      p=(<span class="keyword">void</span>*)<span class="number">1</span>;</span><br><span class="line">      pthread_exit(p);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    ret=pthread_create(&amp;pthid,<span class="literal">NULL</span>,threadFunc,<span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret,<span class="string">"pthread_create"</span>);</span><br><span class="line">    <span class="keyword">long</span> threadRetVal;</span><br><span class="line">    ret=pthread_join(pthid,(<span class="keyword">void</span>**)&amp;threadRetVal);</span><br><span class="line">    THREAD_ERROR_CHECK(ret,<span class="string">"pthread_join"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread %ld\n"</span>,threadRetVal);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am child thread</span><br><span class="line">I am main thread 1</span><br></pre></td></tr></table></figure>

<h2 id="线程的取消"><a href="#线程的取消" class="headerlink" title="线程的取消"></a>线程的取消</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<p>线程取消的方法是一个线程向目标线程发cancel信号，但是如何处理cancel信号则由目标线程自己决定，目标线程或者忽略、或者立即终止、或者继续运行至cancelation-point(取消点)后终止。</p>
<h3 id="取消点"><a href="#取消点" class="headerlink" title="取消点"></a>取消点</h3><p>根据POSIX标准，pthread_join()、pthread_testcancel()、pthread_cond_wait()、pthread_cond_timedwait()、sem_wait()、sigwait()等函数以及read()、write()等会引起阻塞的系统调用都是Cancelation-point。</p>
<h2 id="线程终止清理函数"><a href="#线程终止清理函数" class="headerlink" title="线程终止清理函数"></a>线程终止清理函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span></span><br></pre></td></tr></table></figure>
<p><code>pthread_cleanup_push()</code>/<code>pthread_cleanup_pop()</code>采用先入后出的栈结构管理。</p>
<h3 id="pthread-cleanup-pop"><a href="#pthread-cleanup-pop" class="headerlink" title="pthread_cleanup_pop():"></a><code>pthread_cleanup_pop()</code>:</h3><p>调用pthread_cleanup_push()时压入清理函数栈，多次对<code>pthread_cleanup_push()</code>的调用将在清理函数栈中形成一个函数链，在执行该函数链时按照压栈的相反顺序弹出。</p>
<h3 id="pthread-cleanup-pop-1"><a href="#pthread-cleanup-pop-1" class="headerlink" title="pthread_cleanup_pop:"></a><code>pthread_cleanup_pop</code>:</h3><p>其参数execute：</p>
<p>1.如果为非0值,则按栈的顺序注销掉一个原来注册的清理函数，并执行该函数；</p>
<p>2.若为0，仅仅在线程调用pthread_exit函数或者其它线程对本线程调用<code>pthread_cancel</code>函数时，才在弹出“清理函数”的同时执行该“清理函数”。</p>
<h2 id="线程的互斥（动态）"><a href="#线程的互斥（动态）" class="headerlink" title="线程的互斥（动态）"></a>线程的互斥（动态）</h2><p>使用mutex函数来实现线程的互斥。</p>
<p>用到的头文件： &lt;pthread.h&gt;</p>
<h3 id="互斥锁的创建"><a href="#互斥锁的创建" class="headerlink" title="互斥锁的创建"></a>互斥锁的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个互斥锁变量:</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex; </span><br><span class="line"><span class="comment">//初始化互斥锁：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁的注销"><a href="#互斥锁的注销" class="headerlink" title="互斥锁的注销"></a>互斥锁的注销</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。</p>
<p>mutexattr：用于指定互斥锁属性（见下），如果为NULL则使用缺省属性。通常为NULL</p>
<h3 id="互斥锁操作"><a href="#互斥锁操作" class="headerlink" title="互斥锁操作"></a>互斥锁操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//解锁:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>加锁注意事项：</p>
<p>1.如果线程在加锁后解锁前被取消，锁将永远保持锁定状态。因此如果在关键区段内有取消点存在，则必须在退出回调函数<code>pthread_cleanup_push</code>/<code>pthread_cleanup_pop</code>中解锁。</p>
<p>2.若对同一线程连续加锁两次，则会产生死锁。</p>
<h2 id="线程的同步（动态）"><a href="#线程的同步（动态）" class="headerlink" title="线程的同步（动态）"></a>线程的同步（动态）</h2><p>使用条件变量实现线程的同步。</p>
<h3 id="条件变量的创建"><a href="#条件变量的创建" class="headerlink" title="条件变量的创建"></a>条件变量的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond; </span><br><span class="line"><span class="comment">//初始化该条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>cond_attr值通常为NULL。</p>
<h3 id="条件变量的注销"><a href="#条件变量的注销" class="headerlink" title="条件变量的注销"></a>条件变量的注销</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<p>只有在没有线程在该条件变量上等待的时候能注销这个条件变量，否则返回EBUSY。</p>
<h3 id="条件的等待"><a href="#条件的等待" class="headerlink" title="条件的等待"></a>条件的等待</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无条件等待</span></span><br><span class="line">pthread_cond_wait();</span><br><span class="line"><span class="comment">//计时等待</span></span><br><span class="line">pthread_cond_timedwait();</span><br></pre></td></tr></table></figure>
<p>无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()</p>
<h3 id="条件的激发"><a href="#条件的激发" class="headerlink" title="条件的激发"></a>条件的激发</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">激活一个等待该条件的线程，</span></span><br><span class="line"><span class="comment">存在多个等待线程时按入队顺序激活其中一个：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">thread_cond_signal()</span><br><span class="line"><span class="comment">//激活所有等待线程：</span></span><br><span class="line">pthread_cond_broadcast()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(20) - 信号</title>
    <url>/2020/01/28/Linux%5B20%5D%20-%20%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(1) - 常用命令</title>
    <url>/2020/01/26/Linux%5B1%5D%20-%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h1><p>新建(添加)用户<br><code>$ useradd [username]</code><br><code>$ useradd -m [username] -s /bin/bash  #添加用户并指定家目录</code> <a id="more"></a><br>配置密码<br><code>$ sudo passwd [username]</code><br>切换用户<br><code>$ su [username]</code><br>显示所有用户<br><code>cat /etc/passwd</code><br>退出当前用户<br><code>$ exit</code><br>删除用户<br><code>$ userdel [username]</code><br><code>$ userdel -r [username] #删除用户及家目录下的文件</code></p>
<h2 id="给某一普通用户配置sudo权限"><a href="#给某一普通用户配置sudo权限" class="headerlink" title="给某一普通用户配置sudo权限"></a>给某一普通用户配置sudo权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.切换到root用户：</span><br><span class="line">$ su root </span><br><span class="line"></span><br><span class="line">#2.添加sudoers文件写权限：</span><br><span class="line">$ chmod u+w &#x2F;etc&#x2F;sudoers </span><br><span class="line"></span><br><span class="line">#3.编辑sudoers文件</span><br><span class="line">vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">#找到 root ALL&#x3D;(ALL) ALL，在他其下面添加：</span><br><span class="line">xxx ALL&#x3D;(ALL) ALL (xxx &#x3D; 用户名)</span><br><span class="line"></span><br><span class="line">#可选一下任意一种形式：</span><br><span class="line">#允许用户youuser执行sudo命令(需要输入密码):</span><br><span class="line">username            ALL&#x3D;(ALL)                ALL</span><br><span class="line">#允许用户组youuser里面的用户执行sudo命令(需要输入密码)：</span><br><span class="line">%username           ALL&#x3D;(ALL)                ALL</span><br><span class="line">#允许用户youuser执行sudo命令,并且在执行的时候不输入密码：</span><br><span class="line">username            ALL&#x3D;(ALL)                NOPASSWD: ALL</span><br><span class="line">#允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码：</span><br><span class="line">%username           ALL&#x3D;(ALL)                NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line">#4.撤销sudoers文件写权限：</span><br><span class="line">$ chmod u-w &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure>
<p>如此，普通用户就可以使用sudo了。<br>（来源：<a href="https://www.jianshu.com/p/3d435e09712a）" target="_blank" rel="noopener">https://www.jianshu.com/p/3d435e09712a）</a></p>
<h1 id="文件目录相关"><a href="#文件目录相关" class="headerlink" title="文件目录相关"></a>文件目录相关</h1><h2 id="显示与查看"><a href="#显示与查看" class="headerlink" title="显示与查看"></a>显示与查看</h2><p>显示当前工作目录<br><code>$ pwd</code><br>查看当前工作目录下所有文件<br><code>$ ls</code><br><code>$ ls -a    #同时显示隐藏文件</code><br><code>$ ls -l    #显示详细信息</code><br><code>$ ls -la   #显示详细信息（包括隐藏文件） 别名：ll</code><br><code>$ ls -lh   #将文件大小按照合适的单位显示</code><br>树状目录结构显示<br><code>$ sudo apt install tree    #首次使用需要安装tree</code><br><code>$ tree [pathname]    #显示目录树状结构</code></p>
<h2 id="转移当前目录"><a href="#转移当前目录" class="headerlink" title="转移当前目录"></a>转移当前目录</h2><p>改变当前工作目录 (前往某一目录)<br><code>$ cd [pathname]</code><br>回到上次目录<br><code>$ cd -</code><br>转移到家目录<br><code>$cd ~</code><br>转移到根目录<br><code>$ cd /</code><br>转移到上级目录<br><code>$ cd ..</code></p>
<h2 id="目录创建与删除"><a href="#目录创建与删除" class="headerlink" title="目录创建与删除"></a>目录创建与删除</h2><p>创建目录<br><code>$ mkdir [cataname]</code><br>删除目录<br><code>$ rmdir [cataname]    #不能删除非空目录</code><br><code>$ rm -rf [cataname]    #删除目录及其下一切文件</code></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>删除文件<br><code>$ rm [mode] [username]|[pathname]</code><br>移动文件<br><code>$ mv [mode] [源文件] [目标路径]|[目标文件]</code><br>拷贝文件<br><code>$ cp [mode] [源文件] [目标路径]|[目标文件]</code></p>
<h1 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h1><h2 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h2><p>通过ls -l 命令可查看当前目录下文件权限</p>
<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p><code>$ chmod [who][+|-|=][mode] [filename]</code></p>
<ul>
<li>who代表用户类型：u表示用户，g表示组成员，o表示其他用户，a或者不写代表所有用户（ugo三个字母可以组合） </li>
<li>+|-|=代表操作符：+表示添加某个权限，-表示取消某个权限，=表示设置成某种权限 </li>
<li>mode代表模式，使用rwx三个字母的组合，r表示可读，w表示可写，x表示可执行</li>
</ul>
<p><code>$ chmod 666 [filename]    #可以用数字表示三类用户的权限</code></p>
<h2 id="修改文件所有者、所在组"><a href="#修改文件所有者、所在组" class="headerlink" title="修改文件所有者、所在组"></a>修改文件所有者、所在组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改文件所有者：</span><br><span class="line">chgrp [username] [filename] -R</span><br><span class="line">#修改文件所在组：</span><br><span class="line">chown [username] [filename]  -R</span><br><span class="line"></span><br><span class="line"># -R表示递归目录下所有文件</span><br></pre></td></tr></table></figure>

<h1 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h1><p>使用find命令来查找文件<br><code>$ find [起始目录] [查找条件] [操作]</code></p>
<h2 id="查找条件"><a href="#查找条件" class="headerlink" title="查找条件"></a>查找条件</h2><p><code>-name</code>            查找文件名匹配所给<strong>字符串</strong>的所有文件，字串内可用通配符*、?、[、]<br><code>-gid</code>             查找属于ID号为n的用户组的所有文件<br><code>-uid</code>             查找属于ID号为n的用户的所有文件<br><code>-group &#39;string&#39;</code>  查找属于用户组名为所给字串的所有的文件<br><code>-user &#39;string&#39;</code>   查找属于用户名为所给字串的所有的文件<br><code>-empty</code>           查找大小为0的目录或文件<br><code>-size n[bckw]</code>    n后面的字符表示单位，缺省为b，代表512字节的块<br><code>-type x</code>          查找类型为x的文件</p>
<h2 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h2><h3 id="用来匹配任意个字符"><a href="#用来匹配任意个字符" class="headerlink" title="* 用来匹配任意个字符"></a>* 用来匹配任意个字符</h3><p>若当前目录里面有文件file，file1，file123，file2，file3，file4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -name &quot;file*&quot;</span><br><span class="line">#结果是</span><br><span class="line">.&#x2F;file1 </span><br><span class="line">.&#x2F;file </span><br><span class="line">.&#x2F;file123</span><br><span class="line">.&#x2F;file2 </span><br><span class="line">.&#x2F;file3 </span><br><span class="line">.&#x2F;file4</span><br></pre></td></tr></table></figure>
<h3 id="用来匹配1个任意字符"><a href="#用来匹配1个任意字符" class="headerlink" title="? 用来匹配1个任意字符"></a>? 用来匹配1个任意字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -name &quot;file?&quot;</span><br><span class="line">#结果是</span><br><span class="line">.&#x2F;file1</span><br><span class="line">.&#x2F;file2</span><br><span class="line">.&#x2F;file3 </span><br><span class="line">.&#x2F;file4</span><br></pre></td></tr></table></figure>
<h3 id="用来匹配某个范围内的字符"><a href="#用来匹配某个范围内的字符" class="headerlink" title="[] 用来匹配某个范围内的字符"></a>[] 用来匹配某个范围内的字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -name &quot;file[0-9]&quot;</span><br><span class="line">#结果是</span><br><span class="line">.&#x2F;file1 </span><br><span class="line">.&#x2F;file2 </span><br><span class="line">.&#x2F;file3 </span><br><span class="line">.&#x2F;file4</span><br></pre></td></tr></table></figure>
<h2 id="根据时间查找"><a href="#根据时间查找" class="headerlink" title="根据时间查找"></a>根据时间查找</h2><p><code>amin n</code> 查找n分钟以前被访问过的所有文件（+表示n分钟之前，-表示n分钟之内，+号和-号都不能省略）<br><code>cmin n</code> 查找n分钟以前文件状态被修改过的所有文件<br><code>mmin n</code> 查找n分钟以前文件内容被修改过的所有文件<br><code>atime n</code> 查找n天以前被访问过的所有文件<br><code>ctime n</code> 查找n天以前文件状态被修改过的所有文件<br><code>mtime n</code> 查找n天以前文件内容被修改过的所有文件</p>
<h1 id="将一些命令封装在一个文件里方便快捷执行"><a href="#将一些命令封装在一个文件里方便快捷执行" class="headerlink" title="将一些命令封装在一个文件里方便快捷执行"></a>将一些命令封装在一个文件里方便快捷执行</h1><p>比如，我想自己定义一个qmake命令来完成以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~&#x2F;Makefile .   #将家目录里写好的Makefile文件拷贝到当前目录</span><br><span class="line">make              #执行make命令</span><br></pre></td></tr></table></figure>
<p>则需要先<code>vim qmake</code> ，将上述代码写进去，<br>然后将qmake文件拷贝到/usr/bin目录下（需使用sudo权限）:<br><code>sudo cp qmake /usr/bin</code><br>当然，需要保证/usr/bin文件夹下没有名为qmake的文件。<br>以后只需要在当前目录下直接输入qmake即可执行定义好的上面两个操作了:)。</p>
<h1 id="sudo-出现unable-to-resolve-host-解决方法"><a href="#sudo-出现unable-to-resolve-host-解决方法" class="headerlink" title="sudo 出现unable to resolve host 解决方法"></a>sudo 出现unable to resolve host 解决方法</h1><p>虽然sudo 还是可以正常执行, 所以就直接从/etc/hosts 设定, 让abc(hostname) 可以解回127.0.0.1 的IP 即可.<br>在127.0.0.1 localhost 后面加上主机名称(hostname) 即可:<br>127.0.0.1       localhost cloud</p>
<h1 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1、方法一使用hostnamectl命令</span><br><span class="line"># hostnamectl set-hostname [hostname]</span><br><span class="line"> </span><br><span class="line">#方法二：修改配置文件 &#x2F;etc&#x2F;hostname </span><br><span class="line"># vim &#x2F;etc&#x2F;hostname</span><br><span class="line">保存退出</span><br></pre></td></tr></table></figure>

<h1 id="ubuntu环境下安装vimplus插件"><a href="#ubuntu环境下安装vimplus插件" class="headerlink" title="ubuntu环境下安装vimplus插件"></a>ubuntu环境下安装vimplus插件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  sudo apt install git </span><br><span class="line"></span><br><span class="line">2  git clone https:&#x2F;&#x2F;gitee.com&#x2F;cskaoyan123&#x2F;vimplus.git ~&#x2F;.vimplus</span><br><span class="line"></span><br><span class="line">3  .cd ~&#x2F;.vimplus</span><br><span class="line"></span><br><span class="line">4  .&#x2F;install.sh</span><br><span class="line"></span><br><span class="line">5  vim-addon-manager remove youcompleteme</span><br><span class="line"></span><br><span class="line">相关帮助文档</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;75cde8a80fd7</span><br><span class="line"></span><br><span class="line">预生成代码在路径</span><br><span class="line">~&#x2F;.vim&#x2F;plugged&#x2F;prepare-code下</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/01/25/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="markdown编辑器"><a href="#markdown编辑器" class="headerlink" title="markdown编辑器"></a>markdown编辑器</h1><p>比较Typora, 目前使用sublime。</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1>]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
