<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux之环境变量PS1</title>
    <url>/2020/02/01/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FPS1/</url>
    <content><![CDATA[<h1 id="1-PS1是什么"><a href="#1-PS1是什么" class="headerlink" title="1.PS1是什么"></a>1.PS1是什么</h1><p>PS1是Linux终端用户的一个环境变量，用来定义命令行提示符的参数。<a id="more"></a><br>输入命令<br><code>$ echo $PS1</code><br>可得到当前定义的PS1值<br><code>\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$</code></p>
<h1 id="2-PS1参数"><a href="#2-PS1参数" class="headerlink" title="2.PS1参数"></a>2.PS1参数</h1><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　\d ：代表日期，格式为weekday month date，例如：&quot;Mon Aug 1&quot;</span><br><span class="line"></span><br><span class="line">　　\H ：完整的主机名称</span><br><span class="line"></span><br><span class="line">　　\h ：仅取主机名中的第一个名字</span><br><span class="line"></span><br><span class="line">　　\t ：显示时间为24小时格式，如：HH：MM：SS</span><br><span class="line"></span><br><span class="line">　　\T ：显示时间为12小时格式</span><br><span class="line"></span><br><span class="line">　　\A ：显示时间为24小时格式：HH：MM</span><br><span class="line"></span><br><span class="line">　　\u ：当前用户的账号名称</span><br><span class="line"></span><br><span class="line">　　\v ：BASH的版本信息</span><br><span class="line"></span><br><span class="line">　　\w ：完整的工作目录名称</span><br><span class="line"></span><br><span class="line">　　\W ：利用basename取得工作目录名称，只显示最后一个目录名</span><br><span class="line"></span><br><span class="line">　　\# ：下达的第几个命令</span><br><span class="line"></span><br><span class="line">　　\$ ：提示字符，如果是root用户，提示符为 # ，普通用户则为 $</span><br></pre></td></tr></table></figure>
<p>所以linux默认的命令行提示信息的格式<br><code>PS1=&#39;[\u@\h \W]\$ &#39;</code>  的意思就是：<br>[当前用户的账号名称@主机名的第一个名字 工作目录的最后一层目录名]#</p>
<p>##颜色设置参数<br>　在PS1中设置字符颜色的格式为：<code>\[\e[F;Bm\]........\[\e[0m\]</code><br>其中“F“为字体颜色，编号为30-37，“B”为背景颜色，编号为40-47,<code>\[\e[0m\]</code>作为颜色设定的结束。</p>
<p>　　颜色对照表：</p>
<p>　　　　F    B</p>
<p>　　　　30  40 黑色</p>
<p>　　　　31  41 红色</p>
<p>　　　　32  42 绿色</p>
<p>　　　　33  43 黄色</p>
<p>　　　　34  44 蓝色</p>
<p>　　　　35  45 紫红色</p>
<p>　　　　36  46 青蓝色</p>
<p>　　　　37  47 白色<br>修改颜色，只需将对应数字套入设置格式中即可。</p>
<p>比如要设置命令行的格式为绿字黑底([\e[32;40m])，显示当前用户的账号名称(\u)、主机的第一个名字(\h)、完整的当前工作目录名称(\w)、24小时格式时间(\t)，可以直接在命令行键入如下命令：<br><code>$ PS1=&#39;[\[\e[32;40m\]\u@\h \w \t]$ \[\e[0m\]&#39;</code><br>用以上方法修改PS1变量只是临时性的，下次登录即恢复原样。</p>
<h1 id="3-修改-bashrc文件-永久保存命令行样式"><a href="#3-修改-bashrc文件-永久保存命令行样式" class="headerlink" title="3.修改.bashrc文件,永久保存命令行样式"></a>3.修改.bashrc文件,永久保存命令行样式</h1><p>在家目录下使用ls -la命令即可看到.bashrc这个文件</p>
<p>编辑.bashrc文件，加入这一行：(以下是本人的设置)</p>
<p><code>export PS1=&quot;\[\e[31;1m\]\u@\[\e[34;1m\]\h \[\e[36;1m\]\w $\[\e[37;1m\] &quot;</code></p>
<p>保存退出，然后重新加载bash配置文件:</p>
<p><code>$ source .bashrc</code></p>
<p>即可永久生效。<br>———<br>参考来源 <a href="https://www.cnblogs.com/Q--T/p/5394993.html" target="_blank" rel="noopener">https://www.cnblogs.com/Q--T/p/5394993.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(21) - 多线程</title>
    <url>/2020/01/29/Linux21%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程是系统中程序执行和资源分配的基本单位。</p>
<p>线程是在共享内存空间中并发执行的多道执行路径，是进程的基本调度单元，一个进程内可拥有多个线程。（程序执行路径即函数栈的弹栈压栈过程）</p>
<p>它与同进程中的其他线程共享进程空间、<a id="more"></a>堆、代码、数据、文件描述符、信号等，只拥有自己的栈空间，大大减少了上下文切换的开销。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>线程和进程在使用上各有优缺点：</p>
<p>&emsp;线程执行开销小，占用的CPU少，线程之间的切换快，但不利于资源的管理和保护。</p>
<p>&emsp;进程正相反，从可移植性来讲，多进程的可移植性要好些。</p>
<h1 id="线程的Linux实现"><a href="#线程的Linux实现" class="headerlink" title="线程的Linux实现"></a>线程的Linux实现</h1><p>使用NPTL线程库实现，在编译时要在编译命令后面加-lpthread。</p>
<p>使用到的头文件为&lt;pthread.h&gt;，使用到的接口以pthread_开头。</p>
<p>因为pthread开头的接口，都不能用perror，故在头文件中新定义一个宏 THREAD_ERROR_CHECK 用来检查返回值是否正确：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_ERROR_CHECK(ret,funcName)\</span></span><br><span class="line"> &#123;<span class="keyword">if</span>(ret!=<span class="number">0</span>)\</span><br><span class="line"> &#123;<span class="built_in">printf</span>(<span class="string">"%s:%s\n"</span>,funcName,strerror(ret));<span class="keyword">return</span> <span class="number">-1</span>;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程的代码实现"><a href="#线程的代码实现" class="headerlink" title="线程的代码实现"></a>线程的代码实现</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>线程创建采用函数pthread_create, 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, </span></span></span><br><span class="line"><span class="function"><span class="params">	           <span class="keyword">pthread_attr_t</span> * attr, </span></span></span><br><span class="line"><span class="function"><span class="params">	           <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="function"><span class="params">	           <span class="keyword">void</span> * arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>thread: 传出参数，保存新线程的标识（进程id）。</p>
<p>attr: 结构体指针，结构中的元素分别指定新线程的运行属性。通常NULL即可。</p>
<p>start_routine: 函数指针，指向新线程的入口点函数(本文命名为threadFunc)。</p>
<p>arg: 用于传递给start_routine指向的入口点函数（即threadFunc函数）的参数，可以为NULL，表示不传递。即向子进程传递参数时就要用的这个变量。</p>
<p>在64位操作系统中，指针变量占8个字节，若通过arg变量传一个整数，则大小也必须为8个字节（如long类型），int类型只占4字节所以不可用。</p>
<p>通常的形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthid;</span><br><span class="line">pthread_create(&amp;pthid,<span class="literal">NULL</span>,pthfunc,<span class="literal">NULL</span>);      <span class="meta">#arg为NULl时</span></span><br><span class="line">pthread_create(&amp;pthid,<span class="literal">NULL</span>,pthfunc,(<span class="keyword">void</span>*)<span class="number">3</span>);  #将<span class="number">3</span>传给threadFunc的参数p</span><br></pre></td></tr></table></figure>
<h2 id="线程函数-threadFunc"><a href="#线程函数-threadFunc" class="headerlink" title="线程函数 threadFunc"></a>线程函数 threadFunc</h2><p>内容为新线程的执行命令，由程序员自己编写，调用pthread_create创建新线程时，把其第3个参数start_routine填为threadFunc，则新线程的活动即为所写。</p>
<h2 id="线程的退出"><a href="#线程的退出" class="headerlink" title="线程的退出"></a>线程的退出</h2><p>线程退出有两种方式：</p>
<p>&emsp;1.线程从入口点函数自然返回(return 返回值，或执行完全部代码)；</p>
<p>&emsp;2.线程主动调用pthread_exit()函数。</p>
<h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">pthread_exit((<span class="keyword">void</span>*)<span class="number">3</span>);<span class="comment">//3作为返回值被pthread_join函数捕获。</span></span><br></pre></td></tr></table></figure>

<h2 id="线程的等待退出"><a href="#线程的等待退出" class="headerlink" title="线程的等待退出"></a>线程的等待退出</h2><p>若通过pthread_exit函数退出，则其参数可以被其它线程用pthread_join函数捕获。</p>
<h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> pthid, <span class="keyword">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure>
<p>1.该函数是一个阻塞函数，一直等到参数th指定的线程返回,；与多进程中的wait或waitpid类似。</p>
<p>2.thread_return是一个传出参数，接收线程函数的返回值。如果线程通过调用pthread_exit()终止，则pthread_exit()中的参数相当于自然返回值，照样可以被其它线程用pthread_join获取到。</p>
<p>3.该函数还有一个非常重要的作用，由于一个进程中的多个线程共享数据段，因此通常在一个线程退出后，退出线程所占用的资源并不会随线程结束而释放。如果pthid线程类型并不是自动清理资源类型的，则th线程退出后，线程本身的资源必须通过其它线程调用pthread_join来清除,这相当于多进程程序中的waitpid。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pthread_example1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;func.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"I am child thread\n"</span>);</span><br><span class="line">      p=(<span class="keyword">void</span>*)<span class="number">1</span>;</span><br><span class="line">      pthread_exit(p);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthid;</span><br><span class="line">    ret=pthread_create(&amp;pthid,<span class="literal">NULL</span>,threadFunc,<span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret,<span class="string">"pthread_create"</span>);</span><br><span class="line">    <span class="keyword">long</span> threadRetVal;</span><br><span class="line">    ret=pthread_join(pthid,(<span class="keyword">void</span>**)&amp;threadRetVal);</span><br><span class="line">    THREAD_ERROR_CHECK(ret,<span class="string">"pthread_join"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am main thread %ld\n"</span>,threadRetVal);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am child thread</span><br><span class="line">I am main thread 1</span><br></pre></td></tr></table></figure>

<h2 id="线程的取消"><a href="#线程的取消" class="headerlink" title="线程的取消"></a>线程的取消</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<p>线程取消的方法是一个线程向目标线程发cancel信号，但是如何处理cancel信号则由目标线程自己决定，目标线程或者忽略、或者立即终止、或者继续运行至cancelation-point(取消点)后终止。</p>
<h3 id="取消点"><a href="#取消点" class="headerlink" title="取消点"></a>取消点</h3><p>根据POSIX标准，pthread_join()、pthread_testcancel()、pthread_cond_wait()、pthread_cond_timedwait()、sem_wait()、sigwait()等函数以及read()、write()等会引起阻塞的系统调用都是Cancelation-point。</p>
<h2 id="线程终止清理函数"><a href="#线程终止清理函数" class="headerlink" title="线程终止清理函数"></a>线程终止清理函数</h2><h2 id="线程的互斥（动态）"><a href="#线程的互斥（动态）" class="headerlink" title="线程的互斥（动态）"></a>线程的互斥（动态）</h2><p>使用mutex函数来实现线程的互斥。</p>
<p>用到的头文件： &lt;pthread.h&gt;</p>
<h3 id="互斥锁的创建"><a href="#互斥锁的创建" class="headerlink" title="互斥锁的创建"></a>互斥锁的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个互斥锁变量:</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex; </span><br><span class="line"><span class="comment">//初始化互斥锁：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁的注销"><a href="#互斥锁的注销" class="headerlink" title="互斥锁的注销"></a>互斥锁的注销</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。</p>
<p>mutexattr：用于指定互斥锁属性（见下），如果为NULL则使用缺省属性。通常为NULL</p>
<h3 id="互斥锁操作"><a href="#互斥锁操作" class="headerlink" title="互斥锁操作"></a>互斥锁操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//解锁:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>加锁注意事项：</p>
<p>1.如果线程在加锁后解锁前被取消，锁将永远保持锁定状态。因此如果在关键区段内有取消点存在，则必须在退出回调函数pthread_cleanup_push/pthread_cleanup_pop中解锁。</p>
<p>2.若对同一线程连续加锁两次，则会产生死锁。</p>
<h2 id="线程的同步（动态）"><a href="#线程的同步（动态）" class="headerlink" title="线程的同步（动态）"></a>线程的同步（动态）</h2><p>使用条件变量实现线程的同步。</p>
<h3 id="条件变量的创建"><a href="#条件变量的创建" class="headerlink" title="条件变量的创建"></a>条件变量的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond; </span><br><span class="line"><span class="comment">//初始化该条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>cond_attr值通常为NULL。</p>
<h3 id="条件变量的注销"><a href="#条件变量的注销" class="headerlink" title="条件变量的注销"></a>条件变量的注销</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<p>只有在没有线程在该条件变量上等待的时候能注销这个条件变量，否则返回EBUSY。</p>
<h3 id="条件的等待"><a href="#条件的等待" class="headerlink" title="条件的等待"></a>条件的等待</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无条件等待</span></span><br><span class="line">pthread_cond_wait();</span><br><span class="line"><span class="comment">//计时等待</span></span><br><span class="line">pthread_cond_timedwait();</span><br></pre></td></tr></table></figure>
<p>无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()</p>
<h3 id="条件的激发"><a href="#条件的激发" class="headerlink" title="条件的激发"></a>条件的激发</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">激活一个等待该条件的线程，</span></span><br><span class="line"><span class="comment">存在多个等待线程时按入队顺序激活其中一个：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">thread_cond_signal()</span><br><span class="line"><span class="comment">//激活所有等待线程：</span></span><br><span class="line">pthread_cond_broadcast()</span><br></pre></td></tr></table></figure>

<h1 id="未整理："><a href="#未整理：" class="headerlink" title="未整理："></a>未整理：</h1><p>栈空间 pthread_stack.c<br>1、传地址<br>主线程里定义一个局部变量，通过传参的方式，把栈地址传给子进程：<br>int i = 10;<br>pthread_creat(&amp;pthid, threadFunc, &amp;i);<br>将threadFunc的p传给i<br>但不能直接使用p，需要转为int<em>型<br>int * pNum = (int *)p;<br>若子进程里执行</em>pNum = 5;<br>则主进程里i的值也变为5<br>2、pthread_twothread.c  1540i为啥用long<br>创建一个新线程，则需要新建一个线程id<br>pthread_join(pthid, NULL);<br>pthread_join(pthid1, NULL);<br>因为时间片轮转调度，赋值操作比创建进程快<br>i赋值以后进程才执行完<br>若解决此问题，则在pthread_create时直接传i的值（(void*i）即在创建的同时赋值，而不是传地址</p>
<p>堆空间<br>主线程里malloc一段空间 指针为p<br>子进程往主进程里放数据<br>strcpy(p, “hello”); （报错 类型不匹配, 先强转p为char*）<br>主进程则可输出hellow</p>
<p>文件 pthread_open.c<br>子进程把文件关闭后，主进程还能读吗 不能<br> pthread_creat(  ,  , 此处必须为长整形)；  1555<br>(void*)p或</p>
<p>线程的等待 pthread_exit.c<br>子线程结束方式 pthread_exit<br>pthread_join 把子线程返回值得指针拿到<br>1608为啥传二级指针<br>int pthread_join(pthread_t th, void **thread_return);<br>**thread_return为二级指针的原因为 此函数内部需要修改一级指针</p>
<p>pthread_exit_value.c</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(20) - 信号</title>
    <url>/2020/01/28/Linux20%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(1) - 常用命令</title>
    <url>/2020/01/26/Linux%5B1%5D%20-%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h1><p>新建(添加)用户<br><code>$ useradd [username]</code><br><code>$ useradd -m [username] -s /bin/bash  #添加用户并指定家目录</code> <a id="more"></a><br>配置密码<br><code>$ sudo passwd [username]</code><br>切换用户<br><code>$ su [username]</code><br>显示所有用户<br><code>cat /etc/passwd</code><br>退出当前用户<br><code>$ exit</code><br>删除用户<br><code>$ userdel [username]</code><br><code>$ userdel -r [username] #删除用户及家目录下的文件</code></p>
<h2 id="给某一普通用户配置sudo权限"><a href="#给某一普通用户配置sudo权限" class="headerlink" title="给某一普通用户配置sudo权限"></a>给某一普通用户配置sudo权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.切换到root用户：</span><br><span class="line">$ su root </span><br><span class="line"></span><br><span class="line">#2.添加sudoers文件写权限：</span><br><span class="line">$ chmod u+w &#x2F;etc&#x2F;sudoers </span><br><span class="line"></span><br><span class="line">#3.编辑sudoers文件</span><br><span class="line">vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">#找到 root ALL&#x3D;(ALL) ALL，在他其下面添加：</span><br><span class="line">xxx ALL&#x3D;(ALL) ALL (xxx &#x3D; 用户名)</span><br><span class="line"></span><br><span class="line">#可选一下任意一种形式：</span><br><span class="line">#允许用户youuser执行sudo命令(需要输入密码):</span><br><span class="line">username            ALL&#x3D;(ALL)                ALL</span><br><span class="line">#允许用户组youuser里面的用户执行sudo命令(需要输入密码)：</span><br><span class="line">%username           ALL&#x3D;(ALL)                ALL</span><br><span class="line">#允许用户youuser执行sudo命令,并且在执行的时候不输入密码：</span><br><span class="line">username            ALL&#x3D;(ALL)                NOPASSWD: ALL</span><br><span class="line">#允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码：</span><br><span class="line">%username           ALL&#x3D;(ALL)                NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line">#4.撤销sudoers文件写权限：</span><br><span class="line">$ chmod u-w &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure>
<p>如此，普通用户就可以使用sudo了。<br>（来源：<a href="https://www.jianshu.com/p/3d435e09712a）" target="_blank" rel="noopener">https://www.jianshu.com/p/3d435e09712a）</a></p>
<h1 id="文件目录相关"><a href="#文件目录相关" class="headerlink" title="文件目录相关"></a>文件目录相关</h1><h2 id="显示与查看"><a href="#显示与查看" class="headerlink" title="显示与查看"></a>显示与查看</h2><p>显示当前工作目录<br><code>$ pwd</code><br>查看当前工作目录下所有文件<br><code>$ ls</code><br><code>$ ls -a    #同时显示隐藏文件</code><br><code>$ ls -l    #显示详细信息</code><br><code>$ ls -la   #显示详细信息（包括隐藏文件） 别名：ll</code><br><code>$ ls -lh   #将文件大小按照合适的单位显示</code><br>树状目录结构显示<br><code>$ sudo apt install tree    #首次使用需要安装tree</code><br><code>$ tree [pathname]    #显示目录树状结构</code></p>
<h2 id="转移当前目录"><a href="#转移当前目录" class="headerlink" title="转移当前目录"></a>转移当前目录</h2><p>改变当前工作目录 (前往某一目录)<br><code>$ cd [pathname]</code><br>回到上次目录<br><code>$ cd -</code><br>转移到家目录<br><code>$cd ~</code><br>转移到根目录<br><code>$ cd /</code><br>转移到上级目录<br><code>$ cd ..</code></p>
<h2 id="目录创建与删除"><a href="#目录创建与删除" class="headerlink" title="目录创建与删除"></a>目录创建与删除</h2><p>创建目录<br><code>$ mkdir [cataname]</code><br>删除目录<br><code>$ rmdir [cataname]    #不能删除非空目录</code><br><code>$ rm -rf [cataname]    #删除目录及其下一切文件</code></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>删除文件<br><code>$ rm [mode] [username]|[pathname]</code><br>移动文件<br><code>$ mv [mode] [源文件] [目标路径]|[目标文件]</code><br>拷贝文件<br><code>$ cp [mode] [源文件] [目标路径]|[目标文件]</code></p>
<h1 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h1><h2 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h2><p>通过ls -l 命令可查看当前目录下文件权限</p>
<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p><code>$ chmod [who][+|-|=][mode] [filename]</code></p>
<ul>
<li>who代表用户类型：u表示用户，g表示组成员，o表示其他用户，a或者不写代表所有用户（ugo三个字母可以组合） </li>
<li>+|-|=代表操作符：+表示添加某个权限，-表示取消某个权限，=表示设置成某种权限 </li>
<li>mode代表模式，使用rwx三个字母的组合，r表示可读，w表示可写，x表示可执行</li>
</ul>
<p><code>$ chmod 666 [filename]    #可以用数字表示三类用户的权限</code></p>
<h2 id="修改文件所有者、所在组"><a href="#修改文件所有者、所在组" class="headerlink" title="修改文件所有者、所在组"></a>修改文件所有者、所在组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改文件所有者：</span><br><span class="line">chgrp [username] [filename] -R</span><br><span class="line">#修改文件所在组：</span><br><span class="line">chown [username] [filename]  -R</span><br><span class="line"></span><br><span class="line"># -R表示递归目录下所有文件</span><br></pre></td></tr></table></figure>

<h1 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h1><p>使用find命令来查找文件<br><code>$ find [起始目录] [查找条件] [操作]</code></p>
<h2 id="查找条件"><a href="#查找条件" class="headerlink" title="查找条件"></a>查找条件</h2><p><code>-name</code>            查找文件名匹配所给<strong>字符串</strong>的所有文件，字串内可用通配符*、?、[、]<br><code>-gid</code>             查找属于ID号为n的用户组的所有文件<br><code>-uid</code>             查找属于ID号为n的用户的所有文件<br><code>-group &#39;string&#39;</code>  查找属于用户组名为所给字串的所有的文件<br><code>-user &#39;string&#39;</code>   查找属于用户名为所给字串的所有的文件<br><code>-empty</code>           查找大小为0的目录或文件<br><code>-size n[bckw]</code>    n后面的字符表示单位，缺省为b，代表512字节的块<br><code>-type x</code>          查找类型为x的文件</p>
<h2 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h2><h3 id="用来匹配任意个字符"><a href="#用来匹配任意个字符" class="headerlink" title="* 用来匹配任意个字符"></a>* 用来匹配任意个字符</h3><p>若当前目录里面有文件file，file1，file123，file2，file3，file4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -name &quot;file*&quot;</span><br><span class="line">#结果是</span><br><span class="line">.&#x2F;file1 </span><br><span class="line">.&#x2F;file </span><br><span class="line">.&#x2F;file123</span><br><span class="line">.&#x2F;file2 </span><br><span class="line">.&#x2F;file3 </span><br><span class="line">.&#x2F;file4</span><br></pre></td></tr></table></figure>
<h3 id="用来匹配1个任意字符"><a href="#用来匹配1个任意字符" class="headerlink" title="? 用来匹配1个任意字符"></a>? 用来匹配1个任意字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -name &quot;file?&quot;</span><br><span class="line">#结果是</span><br><span class="line">.&#x2F;file1</span><br><span class="line">.&#x2F;file2</span><br><span class="line">.&#x2F;file3 </span><br><span class="line">.&#x2F;file4</span><br></pre></td></tr></table></figure>
<h3 id="用来匹配某个范围内的字符"><a href="#用来匹配某个范围内的字符" class="headerlink" title="[] 用来匹配某个范围内的字符"></a>[] 用来匹配某个范围内的字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -name &quot;file[0-9]&quot;</span><br><span class="line">#结果是</span><br><span class="line">.&#x2F;file1 </span><br><span class="line">.&#x2F;file2 </span><br><span class="line">.&#x2F;file3 </span><br><span class="line">.&#x2F;file4</span><br></pre></td></tr></table></figure>
<h2 id="根据时间查找"><a href="#根据时间查找" class="headerlink" title="根据时间查找"></a>根据时间查找</h2><p><code>amin n</code> 查找n分钟以前被访问过的所有文件（+表示n分钟之前，-表示n分钟之内，+号和-号都不能省略）<br><code>cmin n</code> 查找n分钟以前文件状态被修改过的所有文件<br><code>mmin n</code> 查找n分钟以前文件内容被修改过的所有文件<br><code>atime n</code> 查找n天以前被访问过的所有文件<br><code>ctime n</code> 查找n天以前文件状态被修改过的所有文件<br><code>mtime n</code> 查找n天以前文件内容被修改过的所有文件</p>
<h1 id="将一些命令封装在一个文件里方便快捷执行"><a href="#将一些命令封装在一个文件里方便快捷执行" class="headerlink" title="将一些命令封装在一个文件里方便快捷执行"></a>将一些命令封装在一个文件里方便快捷执行</h1><p>比如，我想自己定义一个qmake命令来完成以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~&#x2F;Makefile .   #将家目录里写好的Makefile文件拷贝到当前目录</span><br><span class="line">make              #执行make命令</span><br></pre></td></tr></table></figure>
<p>则需要先<code>vim qmake</code> ，将上述代码写进去，<br>然后将qmake文件拷贝到/usr/bin目录下（需使用sudo权限）:<br><code>sudo cp qmake /usr/bin</code><br>当然，需要保证/usr/bin文件夹下没有名为qmake的文件。<br>以后只需要在当前目录下直接输入qmake即可执行定义好的上面两个操作了:)。</p>
<p>#sudo 出现unable to resolve host 解决方法<br>虽然sudo 还是可以正常执行, 所以就直接从/etc/hosts 设定, 让abc(hostname) 可以解回127.0.0.1 的IP 即可.<br>在127.0.0.1 localhost 后面加上主机名称(hostname) 即可:<br>127.0.0.1       localhost cloud</p>
<p>#环境变量PS1<br>参考来源：<a href="https://www.cnblogs.com/Q--T/p/5394993.html" target="_blank" rel="noopener">https://www.cnblogs.com/Q--T/p/5394993.html</a><br>PS1是Linux终端用户的一个环境变量，用来定义命令行提示符的参数。<br>在终端输入命令：</p>
<p>export PS1=”[\e[31;1m]\u@[\e[34;1m]\h [\e[36;1m]\w $[\e[37;1m] “ </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/01/25/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="markdown编辑器"><a href="#markdown编辑器" class="headerlink" title="markdown编辑器"></a>markdown编辑器</h1><p>不喜欢Typora, 目前使用sublime。</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1>]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
